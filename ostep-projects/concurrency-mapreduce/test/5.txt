Data type: struct entry
The underlying type of ENTRY.

Function: ENTRY * hsearch (ENTRY item, ACTION action)
Preliminary: | MT-Unsafe race:hsearch | AS-Unsafe | AC-Unsafe corrupt/action==ENTER | See POSIX Safety Concepts.

To search in a hashing table created using hcreate the hsearch function must be used. This function can perform a simple search for an element (if action has the value FIND) or it can alternatively insert the key element into the hashing table. Entries are never replaced.

The key is denoted by a pointer to an object of type ENTRY. For locating the corresponding position in the hashing table only the key element of the structure is used.

If an entry with a matching key is found the action parameter is irrelevant. The found entry is returned. If no matching entry is found and the action parameter has the value FIND the function returns a NULL pointer. If no entry is found and the action parameter has the value ENTER a new entry is added to the hashing table which is initialized with the parameter item. A pointer to the newly added entry is returned.

As mentioned before, the hashing table used by the functions described so far is global and there can be at any time at most one hashing table in the program. A solution is to use the following functions which are a GNU extension. All have in common that they operate on a hashing table which is described by the content of an object of the type struct hsearch_data. This type should be treated as opaque, none of its members should be changed directly.

Function: int hcreate_r (size_t nel, struct hsearch_data *htab)
Preliminary: | MT-Safe race:htab | AS-Unsafe heap | AC-Unsafe corrupt mem | See POSIX Safety Concepts.

The hcreate_r function initializes the object pointed to by htab to contain a hashing table with at least nel elements. So this function is equivalent to the hcreate function except that the initialized data structure is controlled by the user.

This allows having more than one hashing table at one time. The memory necessary for the struct hsearch_data object can be allocated dynamically. It must be initialized with zero before calling this function.

The return value is non-zero if the operation was successful. If the return value is zero, something went wrong, which probably means the program ran out of memory.

Function: void hdestroy_r (struct hsearch_data *htab)
Preliminary: | MT-Safe race:htab | AS-Unsafe heap | AC-Unsafe corrupt mem | See POSIX Safety Concepts.

The hdestroy_r function frees all resources allocated by the hcreate_r function for this very same object htab. As for hdestroy it is the program’s responsibility to free the strings for the elements of the table.

Function: int hsearch_r (ENTRY item, ACTION action, ENTRY **retval, struct hsearch_data *htab)
Preliminary: | MT-Safe race:htab | AS-Safe | AC-Unsafe corrupt/action==ENTER | See POSIX Safety Concepts.

The hsearch_r function is equivalent to hsearch. The meaning of the first two arguments is identical. But instead of operating on a single global hashing table the function works on the table described by the object pointed to by htab (which is initialized by a call to hcreate_r).

Another difference to hcreate is that the pointer to the found entry in the table is not the return value of the function. It is returned by storing it in a pointer variable pointed to by the retval parameter. The return value of the function is an integer value indicating success if it is non-zero and failure if it is zero. In the latter case the global variable errno signals the reason for the failure.

ENOMEM
The table is filled and hsearch_r was called with a so far unknown key and action set to ENTER.

ESRCH
The action parameter is FIND and no corresponding element is found in the table.

Previous: The hsearch function., Up: Searching and Sorting   [Contents][Index]

9.6 The tsearch function.
Another common form to organize data for efficient search is to use trees. The tsearch function family provides a nice interface to functions to organize possibly large amounts of data by providing a mean access time proportional to the logarithm of the number of elements. The GNU C Library implementation even guarantees that this bound is never exceeded even for input data which cause problems for simple binary tree implementations.

The functions described in the chapter are all described in the System V and X/Open specifications and are therefore quite portable.

In contrast to the hsearch functions the tsearch functions can be used with arbitrary data and not only zero-terminated strings.

The tsearch functions have the advantage that no function to initialize data structures is necessary. A simple pointer of type void * initialized to NULL is a valid tree and can be extended or searched. The prototypes for these functions can be found in the header file search.h.

Function: void * tsearch (const void *key, void **rootp, comparison_fn_t compar)
Preliminary: | MT-Safe race:rootp | AS-Unsafe heap | AC-Unsafe corrupt mem | See POSIX Safety Concepts.

The tsearch function searches in the tree pointed to by *rootp for an element matching key. The function pointed to by compar is used to determine whether two elements match. See Defining the Comparison Function, for a specification of the functions which can be used for the compar parameter.

If the tree does not contain a matching entry the key value will be added to the tree. tsearch does not make a copy of the object pointed to by key (how could it since the size is unknown). Instead it adds a reference to this object which means the object must be available as long as the tree data structure is used.

The tree is represented by a pointer to a pointer since it is sometimes necessary to change the root node of the tree. So it must not be assumed that the variable pointed to by rootp has the same value after the call. This also shows that it is not safe to call the tsearch function more than once at the same time using the same tree. It is no problem to run it more than once at a time on different trees.

The return value is a pointer to the matching element in the tree. If a new element was created the pointer points to the new data (which is in fact key). If an entry had to be created and the program ran out of space NULL is returned.

Function: void * tfind (const void *key, void *const *rootp, comparison_fn_t compar)
Preliminary: | MT-Safe race:rootp | AS-Safe | AC-Safe | See POSIX Safety Concepts.

The tfind function is similar to the tsearch function. It locates an element matching the one pointed to by key and returns a pointer to this element. But if no matching element is available no new element is entered (note that the rootp parameter points to a constant pointer). Instead the function returns NULL.

Another advantage of the tsearch functions in contrast to the hsearch functions is that there is an easy way to remove elements.

Function: void * tdelete (const void *key, void **rootp, comparison_fn_t compar)
Preliminary: | MT-Safe race:rootp | AS-Unsafe heap | AC-Unsafe corrupt mem | See POSIX Safety Concepts.

To remove a specific element matching key from the tree tdelete can be used. It locates the matching element using the same method as tfind. The corresponding element is then removed and a pointer to the parent of the deleted node is returned by the function. If there is no matching entry in the tree nothing can be deleted and the function returns NULL. If the root of the tree is deleted tdelete returns some unspecified value not equal to NULL.

Function: void tdestroy (void *vroot, __free_fn_t freefct)
Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | See POSIX Safety Concepts.

If the complete search tree has to be removed one can use tdestroy. It frees all resources allocated by the tsearch functions to generate the tree pointed to by vroot.

For the data in each tree node the function freefct is called. The pointer to the data is passed as the argument to the function. If no such work is necessary freefct must point to a function doing nothing. It is called in any case.

This function is a GNU extension and not covered by the System V or X/Open specifications.

In addition to the functions to create and destroy the tree data structure, there is another function which allows you to apply a function to all elements of the tree. The function must have this type:

void __action_fn_t (const void *nodep, VISIT value, int level);
The nodep is the data value of the current node (once given as the key argument to tsearch). level is a numeric value which corresponds to the depth of the current node in the tree. The root node has the depth 0 and its children have a depth of 1 and so on. The VISIT type is an enumeration type.

Data Type: VISIT
The VISIT value indicates the status of the current node in the tree and how the function is called. The status of a node is either ‘leaf’ or ‘internal node’. For each leaf node the function is called exactly once, for each internal node it is called three times: before the first child is processed, after the first child is processed and after both children are processed. This makes it possible to handle all three methods of tree traversal (or even a combination of them).

preorder
The current node is an internal node and the function is called before the first child was processed.

postorder
The current node is an internal node and the function is called after the first child was processed.

endorder
The current node is an internal node and the function is called after the second child was processed.

leaf
The current node is a leaf.

Function: void twalk (const void *root, __action_fn_t action)
Preliminary: | MT-Safe race:root | AS-Safe | AC-Safe | See POSIX Safety Concepts.

For each node in the tree with a node pointed to by root, the twalk function calls the function provided by the parameter action. For leaf nodes the function is called exactly once with value set to leaf. For internal nodes the function is called three times, setting the value parameter or action to the appropriate value. The level argument for the action function is computed while descending the tree by increasing the value by one for each descent to a child, starting with the value 0 for the root node.

Since the functions used for the action parameter to twalk must not modify the tree data, it is safe to run twalk in more than one thread at the same time, working on the same tree. It is also safe to call tfind in parallel. Functions which modify the tree must not be used, otherwise the behavior is undefined. However, it is difficult to pass data external to the tree to the callback function without resorting to global variables (and thread safety issues), so see the twalk_r function below.

Function: void twalk_r (const void *root, void (*action) (const void *key, VISIT which, void *closure), void *closure)
Preliminary: | MT-Safe race:root | AS-Safe | AC-Safe | See POSIX Safety Concepts.

For each node in the tree with a node pointed to by root, the twalk_r function calls the function provided by the parameter action. For leaf nodes the function is called exactly once with which set to leaf. For internal nodes the function is called three times, setting the which parameter of action to the appropriate value. The closure parameter is passed down to each call of the action function, unmodified.

It is possible to implement the twalk function on top of the twalk_r function, which is why there is no separate level parameter.


#include <search.h>

struct twalk_with_twalk_r_closure
{
  void (*action) (const void *, VISIT, int);
  int depth;
};

static void
twalk_with_twalk_r_action (const void *nodep, VISIT which, void *closure0)
{
  struct twalk_with_twalk_r_closure *closure = closure0;

  switch (which)
    {
    case leaf:
      closure->action (nodep, which, closure->depth);
      break;
    case preorder:
      closure->action (nodep, which, closure->depth);
      ++closure->depth;
      break;
    case postorder:
      /* The preorder action incremented the depth. */
      closure->action (nodep, which, closure->depth - 1);
      break;
    case endorder:
      --closure->depth;
      closure->action (nodep, which, closure->depth);
      break;
    }
}

void
twalk (const void *root, void (*action) (const void *, VISIT, int))
{
  struct twalk_with_twalk_r_closure closure = { action, 0 };
  twalk_r (root, twalk_with_twalk_r_action, &closure);
}
Next: Input/Output Overview, Previous: Searching and Sorting, Up: Main Menu   [Contents][Index]

10 Pattern Matching
The GNU C Library provides pattern matching facilities for two kinds of patterns: regular expressions and file-name wildcards. The library also provides a facility for expanding variable and command references and parsing text into words in the way the shell does.

Wildcard Matching
Globbing
Regular Expression Matching
Shell-Style Word Expansion
Next: Globbing, Up: Pattern Matching   [Contents][Index]

10.1 Wildcard Matching
This section describes how to match a wildcard pattern against a particular string. The result is a yes or no answer: does the string fit the pattern or not. The symbols described here are all declared in fnmatch.h.

Function: int fnmatch (const char *pattern, const char *string, int flags)
Preliminary: | MT-Safe env locale | AS-Unsafe heap | AC-Unsafe mem | See POSIX Safety Concepts.

This function tests whether the string string matches the pattern pattern. It returns 0 if they do match; otherwise, it returns the nonzero value FNM_NOMATCH. The arguments pattern and string are both strings.

The argument flags is a combination of flag bits that alter the details of matching. See below for a list of the defined flags.

In the GNU C Library, fnmatch might sometimes report “errors” by returning nonzero values that are not equal to FNM_NOMATCH.

These are the available flags for the flags argument:

FNM_FILE_NAME
Treat the ‘/’ character specially, for matching file names. If this flag is set, wildcard constructs in pattern cannot match ‘/’ in string. Thus, the only way to match ‘/’ is with an explicit ‘/’ in pattern.

FNM_PATHNAME
This is an alias for FNM_FILE_NAME; it comes from POSIX.2. We don’t recommend this name because we don’t use the term “pathname” for file names.

FNM_PERIOD
Treat the ‘.’ character specially if it appears at the beginning of string. If this flag is set, wildcard constructs in pattern cannot match ‘.’ as the first character of string.

If you set both FNM_PERIOD and FNM_FILE_NAME, then the special treatment applies to ‘.’ following ‘/’ as well as to ‘.’ at the beginning of string. (The shell uses the FNM_PERIOD and FNM_FILE_NAME flags together for matching file names.)

FNM_NOESCAPE
Don’t treat the ‘\’ character specially in patterns. Normally, ‘\’ quotes the following character, turning off its special meaning (if any) so that it matches only itself. When quoting is enabled, the pattern ‘\?’ matches only the string ‘?’, because the question mark in the pattern acts like an ordinary character.

If you use FNM_NOESCAPE, then ‘\’ is an ordinary character.

FNM_LEADING_DIR
Ignore a trailing sequence of characters starting with a ‘/’ in string; that is to say, test whether string starts with a directory name that pattern matches.

If this flag is set, either ‘foo*’ or ‘foobar’ as a pattern would match the string ‘foobar/frobozz’.

FNM_CASEFOLD
Ignore case in comparing string to pattern.

FNM_EXTMATCH
Besides the normal patterns, also recognize the extended patterns introduced in ksh. The patterns are written in the form explained in the following table where pattern-list is a | separated list of patterns.

?(pattern-list)
The pattern matches if zero or one occurrences of any of the patterns in the pattern-list allow matching the input string.

*(pattern-list)
The pattern matches if zero or more occurrences of any of the patterns in the pattern-list allow matching the input string.

+(pattern-list)
The pattern matches if one or more occurrences of any of the patterns in the pattern-list allow matching the input string.

@(pattern-list)
The pattern matches if exactly one occurrence of any of the patterns in the pattern-list allows matching the input string.

!(pattern-list)
The pattern matches if the input string cannot be matched with any of the patterns in the pattern-list.

Next: Regular Expression Matching, Previous: Wildcard Matching, Up: Pattern Matching   [Contents][Index]

10.2 Globbing
The archetypal use of wildcards is for matching against the files in a directory, and making a list of all the matches. This is called globbing.

You could do this using fnmatch, by reading the directory entries one by one and testing each one with fnmatch. But that would be slow (and complex, since you would have to handle subdirectories by hand).

The library provides a function glob to make this particular use of wildcards convenient. glob and the other symbols in this section are declared in glob.h.

Calling glob
Flags for Globbing
More Flags for Globbing
Next: Flags for Globbing, Up: Globbing   [Contents][Index]

10.2.1 Calling glob
The result of globbing is a vector of file names (strings). To return this vector, glob uses a special data type, glob_t, which is a structure. You pass glob the address of the structure, and it fills in the structure’s fields to tell you about the results.

Data Type: glob_t
This data type holds a pointer to a word vector. More precisely, it records both the address of the word vector and its size. The GNU implementation contains some more fields which are non-standard extensions.

gl_pathc
The number of elements in the vector, excluding the initial null entries if the GLOB_DOOFFS flag is used (see gl_offs below).

gl_pathv
The address of the vector. This field has type char **.

gl_offs
The offset of the first real element of the vector, from its nominal address in the gl_pathv field. Unlike the other fields, this is always an input to glob, rather than an output from it.

If you use a nonzero offset, then that many elements at the beginning of the vector are left empty. (The glob function fills them with null pointers.)

The gl_offs field is meaningful only if you use the GLOB_DOOFFS flag. Otherwise, the offset is always zero regardless of what is in this field, and the first real element comes at the beginning of the vector.

gl_closedir
The address of an alternative implementation of the closedir function. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is void (*) (void *).

This is a GNU extension.

gl_readdir
The address of an alternative implementation of the readdir function used to read the contents of a directory. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is struct dirent *(*) (void *).

An implementation of gl_readdir needs to initialize the following members of the struct dirent object:

d_type
This member should be set to the file type of the entry if it is known. Otherwise, the value DT_UNKNOWN can be used. The glob function may use the specified file type to avoid callbacks in cases where the file type indicates that the data is not required.

d_ino
This member needs to be non-zero, otherwise glob may skip the current entry and call the gl_readdir callback function again to retrieve another entry.

d_name
This member must be set to the name of the entry. It must be null-terminated.

The example below shows how to allocate a struct dirent object containing a given name.


#include <dirent.h>
#include <errno.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

struct dirent *
mkdirent (const char *name)
{
  size_t dirent_size = offsetof (struct dirent, d_name) + 1;
  size_t name_length = strlen (name);
  size_t total_size = dirent_size + name_length;
  if (total_size < dirent_size)
    {
      errno = ENOMEM;
      return NULL;
    }
  struct dirent *result = malloc (total_size);
  if (result == NULL)
    return NULL;
  result->d_type = DT_UNKNOWN;
  result->d_ino = 1;            /* Do not skip this entry. */
  memcpy (result->d_name, name, name_length + 1);
  return result;
}
The glob function reads the struct dirent members listed above and makes a copy of the file name in the d_name member immediately after the gl_readdir callback function returns. Future invocations of any of the callback functions may deallocate or reuse the buffer. It is the responsibility of the caller of the glob function to allocate and deallocate the buffer, around the call to glob or using the callback functions. For example, an application could allocate the buffer in the gl_readdir callback function, and deallocate it in the gl_closedir callback function.

The gl_readdir member is a GNU extension.

gl_opendir
The address of an alternative implementation of the opendir function. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is void *(*) (const char *).

This is a GNU extension.

gl_stat
The address of an alternative implementation of the stat function to get information about an object in the filesystem. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is int (*) (const char *, struct stat *).

This is a GNU extension.

gl_lstat
The address of an alternative implementation of the lstat function to get information about an object in the filesystems, not following symbolic links. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is int (*) (const char *, struct stat *).

This is a GNU extension.

gl_flags
The flags used when glob was called. In addition, GLOB_MAGCHAR might be set. See Flags for Globbing for more details.

This is a GNU extension.

For use in the glob64 function glob.h contains another definition for a very similar type. glob64_t differs from glob_t only in the types of the members gl_readdir, gl_stat, and gl_lstat.

Data Type: glob64_t
This data type holds a pointer to a word vector. More precisely, it records both the address of the word vector and its size. The GNU implementation contains some more fields which are non-standard extensions.

gl_pathc
The number of elements in the vector, excluding the initial null entries if the GLOB_DOOFFS flag is used (see gl_offs below).

gl_pathv
The address of the vector. This field has type char **.

gl_offs
The offset of the first real element of the vector, from its nominal address in the gl_pathv field. Unlike the other fields, this is always an input to glob, rather than an output from it.

If you use a nonzero offset, then that many elements at the beginning of the vector are left empty. (The glob function fills them with null pointers.)

The gl_offs field is meaningful only if you use the GLOB_DOOFFS flag. Otherwise, the offset is always zero regardless of what is in this field, and the first real element comes at the beginning of the vector.

gl_closedir
The address of an alternative implementation of the closedir function. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is void (*) (void *).

This is a GNU extension.

gl_readdir
The address of an alternative implementation of the readdir64 function used to read the contents of a directory. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is struct dirent64 *(*) (void *).

This is a GNU extension.

gl_opendir
The address of an alternative implementation of the opendir function. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is void *(*) (const char *).

This is a GNU extension.

gl_stat
The address of an alternative implementation of the stat64 function to get information about an object in the filesystem. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is int (*) (const char *, struct stat64 *).

This is a GNU extension.

gl_lstat
The address of an alternative implementation of the lstat64 function to get information about an object in the filesystems, not following symbolic links. It is used if the GLOB_ALTDIRFUNC bit is set in the flag parameter. The type of this field is int (*) (const char *, struct stat64 *).

This is a GNU extension.

gl_flags
The flags used when glob was called. In addition, GLOB_MAGCHAR might be set. See Flags for Globbing for more details.

This is a GNU extension.

Function: int glob (const char *pattern, int flags, int (*errfunc) (const char *filename, int error-code), glob_t *vector-ptr)
Preliminary: | MT-Unsafe race:utent env sig:ALRM timer locale | AS-Unsafe dlopen plugin corrupt heap lock | AC-Unsafe corrupt lock fd mem | See POSIX Safety Concepts.

The function glob does globbing using the pattern pattern in the current directory. It puts the result in a newly allocated vector, and stores the size and address of this vector into *vector-ptr. The argument flags is a combination of bit flags; see Flags for Globbing, for details of the flags.

The result of globbing is a sequence of file names. The function glob allocates a string for each resulting word, then allocates a vector of type char ** to store the addresses of these strings. The last element of the vector is a null pointer. This vector is called the word vector.

To return this vector, glob stores both its address and its length (number of elements, not counting the terminating null pointer) into *vector-ptr.

Normally, glob sorts the file names alphabetically before returning them. You can turn this off with the flag GLOB_NOSORT if you want to get the information as fast as possible. Usually it’s a good idea to let glob sort them—if you process the files in alphabetical order, the users will have a feel for the rate of progress that your application is making.

If glob succeeds, it returns 0. Otherwise, it returns one of these error codes:

GLOB_ABORTED
There was an error opening a directory, and you used the flag GLOB_ERR or your specified errfunc returned a nonzero value. for an explanation of the GLOB_ERR flag and errfunc.

GLOB_NOMATCH
The pattern didn’t match any existing files. If you use the GLOB_NOCHECK flag, then you never get this error code, because that flag tells glob to pretend that the pattern matched at least one file.

GLOB_NOSPACE
It was impossible to allocate memory to hold the result.

In the event of an error, glob stores information in *vector-ptr about all the matches it has found so far.

It is important to notice that the glob function will not fail if it encounters directories or files which cannot be handled without the LFS interfaces. The implementation of glob is supposed to use these functions internally. This at least is the assumption made by the Unix standard. The GNU extension of allowing the user to provide their own directory handling and stat functions complicates things a bit. If these callback functions are used and a large file or directory is encountered glob can fail.

Function: int glob64 (const char *pattern, int flags, int (*errfunc) (const char *filename, int error-code), glob64_t *vector-ptr)
Preliminary: | MT-Unsafe race:utent env sig:ALRM timer locale | AS-Unsafe dlopen corrupt heap lock | AC-Unsafe corrupt lock fd mem | See POSIX Safety Concepts.

The glob64 function was added as part of the Large File Summit extensions but is not part of the original LFS proposal. The reason for this is simple: it is not necessary. The necessity for a glob64 function is added by the extensions of the GNU glob implementation which allows the user to provide their own directory handling and stat functions. The readdir and stat functions do depend on the choice of _FILE_OFFSET_BITS since the definition of the types struct dirent and struct stat will change depending on the choice.

Besides this difference, glob64 works just like glob in all aspects.

This function is a GNU extension.

Next: More Flags for Globbing, Previous: Calling glob, Up: Globbing   [Contents][Index]

10.2.2 Flags for Globbing
This section describes the standard flags that you can specify in the flags argument to glob. Choose the flags you want, and combine them with the C bitwise OR operator |.

Note that there are More Flags for Globbing available as GNU extensions.

GLOB_APPEND
Append the words from this expansion to the vector of words produced by previous calls to glob. This way you can effectively expand several words as if they were concatenated with spaces between them.

In order for appending to work, you must not modify the contents of the word vector structure between calls to glob. And, if you set GLOB_DOOFFS in the first call to glob, you must also set it when you append to the results.

Note that the pointer stored in gl_pathv may no longer be valid after you call glob the second time, because glob might have relocated the vector. So always fetch gl_pathv from the glob_t structure after each glob call; never save the pointer across calls.

GLOB_DOOFFS
Leave blank slots at the beginning of the vector of words. The gl_offs field says how many slots to leave. The blank slots contain null pointers.

GLOB_ERR
Give up right away and report an error if there is any difficulty reading the directories that must be read in order to expand pattern fully. Such difficulties might include a directory in which you don’t have the requisite access. Normally, glob tries its best to keep on going despite any errors, reading whatever directories it can.

You can exercise even more control than this by specifying an error-handler function errfunc when you call glob. If errfunc is not a null pointer, then glob doesn’t give up right away when it can’t read a directory; instead, it calls errfunc with two arguments, like this:

(*errfunc) (filename, error-code)
The argument filename is the name of the directory that glob couldn’t open or couldn’t read, and error-code is the errno value that was reported to glob.

If the error handler function returns nonzero, then glob gives up right away. Otherwise, it continues.

GLOB_MARK
If the pattern matches the name of a directory, append ‘/’ to the directory’s name when returning it.

GLOB_NOCHECK
If the pattern doesn’t match any file names, return the pattern itself as if it were a file name that had been matched. (Normally, when the pattern doesn’t match anything, glob returns that there were no matches.)

GLOB_NOESCAPE
Don’t treat the ‘\’ character specially in patterns. Normally, ‘\’ quotes the following character, turning off its special meaning (if any) so that it matches only itself. When quoting is enabled, the pattern ‘\?’ matches only the string ‘?’, because the question mark in the pattern acts like an ordinary character.

If you use GLOB_NOESCAPE, then ‘\’ is an ordinary character.

glob does its work by calling the function fnmatch repeatedly. It handles the flag GLOB_NOESCAPE by turning on the FNM_NOESCAPE flag in calls to fnmatch.

GLOB_NOSORT
Don’t sort the file names; return them in no particular order. (In practice, the order will depend on the order of the entries in the directory.) The only reason not to sort is to save time.

Previous: Flags for Globbing, Up: Globbing   [Contents][Index]

10.2.3 More Flags for Globbing
Beside the flags described in the last section, the GNU implementation of glob allows a few more flags which are also defined in the glob.h file. Some of the extensions implement functionality which is available in modern shell implementations.

GLOB_PERIOD
The . character (period) is treated special. It cannot be matched by wildcards. See Wildcard Matching, FNM_PERIOD.

GLOB_MAGCHAR
The GLOB_MAGCHAR value is not to be given to glob in the flags parameter. Instead, glob sets this bit in the gl_flags element of the glob_t structure provided as the result if the pattern used for matching contains any wildcard character.

GLOB_ALTDIRFUNC
Instead of using the normal functions for accessing the filesystem the glob implementation uses the user-supplied functions specified in the structure pointed to by pglob parameter. For more information about the functions refer to the sections about directory handling see Accessing Directories, and Reading the Attributes of a File.

GLOB_BRACE
If this flag is given, the handling of braces in the pattern is changed. It is now required that braces appear correctly grouped. I.e., for each opening brace there must be a closing one. Braces can be used recursively. So it is possible to define one brace expression in another one. It is important to note that the range of each brace expression is completely contained in the outer brace expression (if there is one).

The string between the matching braces is separated into single expressions by splitting at , (comma) characters. The commas themselves are discarded. Please note what we said above about recursive brace expressions. The commas used to separate the subexpressions must be at the same level. Commas in brace subexpressions are not matched. They are used during expansion of the brace expression of the deeper level. The example below shows this

glob ("{foo/{,bar,biz},baz}", GLOB_BRACE, NULL, &result)
is equivalent to the sequence

glob ("foo/", GLOB_BRACE, NULL, &result)
glob ("foo/bar", GLOB_BRACE|GLOB_APPEND, NULL, &result)
glob ("foo/biz", GLOB_BRACE|GLOB_APPEND, NULL, &result)
glob ("baz", GLOB_BRACE|GLOB_APPEND, NULL, &result)
if we leave aside error handling.

GLOB_NOMAGIC
If the pattern contains no wildcard constructs (it is a literal file name), return it as the sole “matching” word, even if no file exists by that name.

GLOB_TILDE
If this flag is used the character ~ (tilde) is handled specially if it appears at the beginning of the pattern. Instead of being taken verbatim it is used to represent the home directory of a known user.

If ~ is the only character in pattern or it is followed by a / (slash), the home directory of the process owner is substituted. Using getlogin and getpwnam the information is read from the system databases. As an example take user bart with his home directory at /home/bart. For him a call like

glob ("~/bin/*", GLOB_TILDE, NULL, &result)
would return the contents of the directory /home/bart/bin. Instead of referring to the own home directory it is also possible to name the home directory of other users. To do so one has to append the user name after the tilde character. So the contents of user homer’s bin directory can be retrieved by

glob ("~homer/bin/*", GLOB_TILDE, NULL, &result)
If the user name is not valid or the home directory cannot be determined for some reason the pattern is left untouched and itself used as the result. I.e., if in the last example home is not available the tilde expansion yields to "~homer/bin/*" and glob is not looking for a directory named ~homer.

This functionality is equivalent to what is available in C-shells if the nonomatch flag is set.

GLOB_TILDE_CHECK
If this flag is used glob behaves as if GLOB_TILDE is given. The only difference is that if the user name is not available or the home directory cannot be determined for other reasons this leads to an error. glob will return GLOB_NOMATCH instead of using the pattern itself as the name.

This functionality is equivalent to what is available in C-shells if the nonomatch flag is not set.

GLOB_ONLYDIR
If this flag is used the globbing function takes this as a hint that the caller is only interested in directories matching the pattern. If the information about the type of the file is easily available non-directories will be rejected but no extra work will be done to determine the information for each file. I.e., the caller must still be able to filter directories out.

This functionality is only available with the GNU glob implementation. It is mainly used internally to increase the performance but might be useful for a user as well and therefore is documented here.

Calling glob will in most cases allocate resources which are used to represent the result of the function call. If the same object of type glob_t is used in multiple call to glob the resources are freed or reused so that no leaks appear. But this does not include the time when all glob calls are done.

Function: void globfree (glob_t *pglob)
Preliminary: | MT-Safe | AS-Unsafe corrupt heap | AC-Unsafe corrupt mem | See POSIX Safety Concepts.

The globfree function frees all resources allocated by previous calls to glob associated with the object pointed to by pglob. This function should be called whenever the currently used glob_t typed object isn’t used anymore.

Function: void globfree64 (glob64_t *pglob)
Preliminary: | MT-Safe | AS-Unsafe corrupt lock | AC-Unsafe corrupt lock fd mem | See POSIX Safety Concepts.

This function is equivalent to globfree but it frees records of type glob64_t which were allocated by glob64.

Next: Shell-Style Word Expansion, Previous: Globbing, Up: Pattern Matching   [Contents][Index]

10.3 Regular Expression Matching
The GNU C Library supports two interfaces for matching regular expressions. One is the standard POSIX.2 interface, and the other is what the GNU C Library has had for many years.

Both interfaces are declared in the header file regex.h. If you define _POSIX_C_SOURCE, then only the POSIX.2 functions, structures, and constants are declared.

POSIX Regular Expression Compilation
Flags for POSIX Regular Expressions
Matching a Compiled POSIX Regular Expression
Match Results with Subexpressions
Complications in Subexpression Matching
POSIX Regexp Matching Cleanup
Next: Flags for POSIX Regular Expressions, Up: Regular Expression Matching   [Contents][Index]

10.3.1 POSIX Regular Expression Compilation
Before you can actually match a regular expression, you must compile it. This is not true compilation—it produces a special data structure, not machine instructions. But it is like ordinary compilation in that its purpose is to enable you to “execute” the pattern fast. (See Matching a Compiled POSIX Regular Expression, for how to use the compiled regular expression for matching.)

There is a special data type for compiled regular expressions:

Data Type: regex_t
This type of object holds a compiled regular expression. It is actually a structure. It has just one field that your programs should look at:

re_nsub
This field holds the number of parenthetical subexpressions in the regular expression that was compiled.

There are several other fields, but we don’t describe them here, because only the functions in the library should use them.

After you create a regex_t object, you can compile a regular expression into it by calling regcomp.

Function: int regcomp (regex_t *restrict compiled, const char *restrict pattern, int cflags)
Preliminary: | MT-Safe locale | AS-Unsafe corrupt heap lock dlopen | AC-Unsafe corrupt lock mem fd | See POSIX Safety Concepts.

The function regcomp “compiles” a regular expression into a data structure that you can use with regexec to match against a string. The compiled regular expression format is designed for efficient matching. regcomp stores it into *compiled.

It’s up to you to allocate an object of type regex_t and pass its address to regcomp.

The argument cflags lets you specify various options that control the syntax and semantics of regular expressions. See Flags for POSIX Regular Expressions.

If you use the flag REG_NOSUB, then regcomp omits from the compiled regular expression the information necessary to record how subexpressions actually match. In this case, you might as well pass 0 for the matchptr and nmatch arguments when you call regexec.

If you don’t use REG_NOSUB, then the compiled regular expression does have the capacity to record how subexpressions match. Also, regcomp tells you how many subexpressions pattern has, by storing the number in compiled->re_nsub. You can use that value to decide how long an array to allocate to hold information about subexpression matches.

regcomp returns 0 if it succeeds in compiling the regular expression; otherwise, it returns a nonzero error code (see the table below). You can use regerror to produce an error message string describing the reason for a nonzero value; see POSIX Regexp Matching Cleanup.

Here are the possible nonzero values that regcomp can return:

REG_BADBR
There was an invalid ‘\{…\}’ construct in the regular expression. A valid ‘\{…\}’ construct must contain either a single number, or two numbers in increasing order separated by a comma.

REG_BADPAT
There was a syntax error in the regular expression.

REG_BADRPT
A repetition operator such as ‘?’ or ‘*’ appeared in a bad position (with no preceding subexpression to act on).

REG_ECOLLATE
The regular expression referred to an invalid collating element (one not defined in the current locale for string collation). See Locale Categories.

REG_ECTYPE
The regular expression referred to an invalid character class name.

REG_EESCAPE
The regular expression ended with ‘\’.

REG_ESUBREG
There was an invalid number in the ‘\digit’ construct.

REG_EBRACK
There were unbalanced square brackets in the regular expression.

REG_EPAREN
An extended regular expression had unbalanced parentheses, or a basic regular expression had unbalanced ‘\(’ and ‘\)’.

REG_EBRACE
The regular expression had unbalanced ‘\{’ and ‘\}’.

REG_ERANGE
One of the endpoints in a range expression was invalid.

REG_ESPACE
regcomp ran out of memory.

Next: Matching a Compiled POSIX Regular Expression, Previous: POSIX Regular Expression Compilation, Up: Regular Expression Matching   [Contents][Index]

10.3.2 Flags for POSIX Regular Expressions
These are the bit flags that you can use in the cflags operand when compiling a regular expression with regcomp.

REG_EXTENDED
Treat the pattern as an extended regular expression, rather than as a basic regular expression.

REG_ICASE
Ignore case when matching letters.

REG_NOSUB
Don’t bother storing the contents of the matchptr array.

REG_NEWLINE
Treat a newline in string as dividing string into multiple lines, so that ‘$’ can match before the newline and ‘^’ can match after. Also, don’t permit ‘.’ to match a newline, and don’t permit ‘[^…]’ to match a newline.

Otherwise, newline acts like any other ordinary character.

Next: Match Results with Subexpressions, Previous: Flags for POSIX Regular Expressions, Up: Regular Expression Matching   [Contents][Index]

10.3.3 Matching a Compiled POSIX Regular Expression
Once you have compiled a regular expression, as described in POSIX Regular Expression Compilation, you can match it against strings using regexec. A match anywhere inside the string counts as success, unless the regular expression contains anchor characters (‘^’ or ‘$’).

Function: int regexec (const regex_t *restrict compiled, const char *restrict string, size_t nmatch, regmatch_t matchptr[restrict], int eflags)
Preliminary: | MT-Safe locale | AS-Unsafe corrupt heap lock dlopen | AC-Unsafe corrupt lock mem fd | See POSIX Safety Concepts.

This function tries to match the compiled regular expression *compiled against string.

regexec returns 0 if the regular expression matches; otherwise, it returns a nonzero value. See the table below for what nonzero values mean. You can use regerror to produce an error message string describing the reason for a nonzero value; see POSIX Regexp Matching Cleanup.

The argument eflags is a word of bit flags that enable various options.

If you want to get information about what part of string actually matched the regular expression or its subexpressions, use the arguments matchptr and nmatch. Otherwise, pass 0 for nmatch, and NULL for matchptr. See Match Results with Subexpressions.

You must match the regular expression with the same set of current locales that were in effect when you compiled the regular expression.

The function regexec accepts the following flags in the eflags argument:

REG_NOTBOL
Do not regard the beginning of the specified string as the beginning of a line; more generally, don’t make any assumptions about what text might precede it.

REG_NOTEOL
Do not regard the end of the specified string as the end of a line; more generally, don’t make any assumptions about what text might follow it.

Here are the possible nonzero values that regexec can return:

REG_NOMATCH
The pattern didn’t match the string. This isn’t really an error.

REG_ESPACE
regexec ran out of memory.

Next: Complications in Subexpression Matching, Previous: Matching a Compiled POSIX Regular Expression, Up: Regular Expression Matching   [Contents][Index]

10.3.4 Match Results with Subexpressions
When regexec matches parenthetical subexpressions of pattern, it records which parts of string they match. It returns that information by storing the offsets into an array whose elements are structures of type regmatch_t. The first element of the array (index 0) records the part of the string that matched the entire regular expression. Each other element of the array records the beginning and end of the part that matched a single parenthetical subexpression.

Data Type: regmatch_t
This is the data type of the matchptr array that you pass to regexec. It contains two structure fields, as follows:

rm_so
The offset in string of the beginning of a substring. Add this value to string to get the address of that part.

rm_eo
The offset in string of the end of the substring.

Data Type: regoff_t
regoff_t is an alias for another signed integer type. The fields of regmatch_t have type regoff_t.

The regmatch_t elements correspond to subexpressions positionally; the first element (index 1) records where the first subexpression matched, the second element records the second subexpression, and so on. The order of the subexpressions is the order in which they begin.

When you call regexec, you specify how long the matchptr array is, with the nmatch argument. This tells regexec how many elements to store. If the actual regular expression has more than nmatch subexpressions, then you won’t get offset information about the rest of them. But this doesn’t alter whether the pattern matches a particular string or not.

If you don’t want regexec to return any information about where the subexpressions matched, you can either supply 0 for nmatch, or use the flag REG_NOSUB when you compile the pattern with regcomp.

Next: POSIX Regexp Matching Cleanup, Previous: Match Results with Subexpressions, Up: Regular Expression Matching   [Contents][Index]

10.3.5 Complications in Subexpression Matching
Sometimes a subexpression matches a substring of no characters. This happens when ‘f\(o*\)’ matches the string ‘fum’. (It really matches just the ‘f’.) In this case, both of the offsets identify the point in the string where the null substring was found. In this example, the offsets are both 1.

Sometimes the entire regular expression can match without using some of its subexpressions at all—for example, when ‘ba\(na\)*’ matches the string ‘ba’, the parenthetical subexpression is not used. When this happens, regexec stores -1 in both fields of the element for that subexpression.

Sometimes matching the entire regular expression can match a particular subexpression more than once—for example, when ‘ba\(na\)*’ matches the string ‘bananana’, the parenthetical subexpression matches three times. When this happens, regexec usually stores the offsets of the last part of the string that matched the subexpression. In the case of ‘bananana’, these offsets are 6 and 8.

But the last match is not always the one that is chosen. It’s more accurate to say that the last opportunity to match is the one that takes precedence. What this means is that when one subexpression appears within another, then the results reported for the inner subexpression reflect whatever happened on the last match of the outer subexpression. For an example, consider ‘\(ba\(na\)*s \)*’ matching the string ‘bananas bas ’. The last time the inner expression actually matches is near the end of the first word. But it is considered again in the second word, and fails to match there. regexec reports nonuse of the “na” subexpression.

Another place where this rule applies is when the regular expression

\(ba\(na\)*s \|nefer\(ti\)* \)*
matches ‘bananas nefertiti’. The “na” subexpression does match in the first word, but it doesn’t match in the second word because the other alternative is used there. Once again, the second repetition of the outer subexpression overrides the first, and within that second repetition, the “na” subexpression is not used. So regexec reports nonuse of the “na” subexpression.

Previous: Complications in Subexpression Matching, Up: Regular Expression Matching   [Contents][Index]

10.3.6 POSIX Regexp Matching Cleanup
When you are finished using a compiled regular expression, you can free the storage it uses by calling regfree.

Function: void regfree (regex_t *compiled)
Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | See POSIX Safety Concepts.

Calling regfree frees all the storage that *compiled points to. This includes various internal fields of the regex_t structure that aren’t documented in this manual.

regfree does not free the object *compiled itself.

You should always free the space in a regex_t structure with regfree before using the structure to compile another regular expression.

When regcomp or regexec reports an error, you can use the function regerror to turn it into an error message string.

Function: size_t regerror (int errcode, const regex_t *restrict compiled, char *restrict buffer, size_t length)
Preliminary: | MT-Safe env | AS-Unsafe corrupt heap lock dlopen | AC-Unsafe corrupt lock fd mem | See POSIX Safety Concepts.

This function produces an error message string for the error code errcode, and stores the string in length bytes of memory starting at buffer. For the compiled argument, supply the same compiled regular expression structure that regcomp or regexec was working with when it got the error. Alternatively, you can supply NULL for compiled; you will still get a meaningful error message, but it might not be as detailed.

If the error message can’t fit in length bytes (including a terminating null character), then regerror truncates it. The string that regerror stores is always null-terminated even if it has been truncated.

The return value of regerror is the minimum length needed to store the entire error message. If this is less than length, then the error message was not truncated, and you can use it. Otherwise, you should call regerror again with a larger buffer.

Here is a function which uses regerror, but always dynamically allocates a buffer for the error message:

char *get_regerror (int errcode, regex_t *compiled)
{
  size_t length = regerror (errcode, compiled, NULL, 0);
  char *buffer = xmalloc (length);
  (void) regerror (errcode, compiled, buffer, length);
  return buffer;
}
Previous: Regular Expression Matching, Up: Pattern Matching   [Contents][Index]

10.4 Shell-Style Word Expansion
Word expansion means the process of splitting a string into words and substituting for variables, commands, and wildcards just as the shell does.

For example, when you write ‘ls -l foo.c’, this string is split into three separate words—‘ls’, ‘-l’ and ‘foo.c’. This is the most basic function of word expansion.

When you write ‘ls *.c’, this can become many words, because the word ‘*.c’ can be replaced with any number of file names. This is called wildcard expansion, and it is also a part of word expansion.

When you use ‘echo $PATH’ to print your path, you are taking advantage of variable substitution, which is also part of word expansion.

Ordinary programs can perform word expansion just like the shell by calling the library function wordexp.

The Stages of Word Expansion
Calling wordexp
Flags for Word Expansion
wordexp Example
Details of Tilde Expansion
Details of Variable Substitution
Next: Calling wordexp, Up: Shell-Style Word Expansion   [Contents][Index]

10.4.1 The Stages of Word Expansion
When word expansion is applied to a sequence of words, it performs the following transformations in the order shown here:

Tilde expansion: Replacement of ‘~foo’ with the name of the home directory of ‘foo’.
Next, three different transformations are applied in the same step, from left to right:
Variable substitution: Environment variables are substituted for references such as ‘$foo’.
Command substitution: Constructs such as ‘`cat foo`’ and the equivalent ‘$(cat foo)’ are replaced with the output from the inner command.
Arithmetic expansion: Constructs such as ‘$(($x-1))’ are replaced with the result of the arithmetic computation.
Field splitting: subdivision of the text into words.
Wildcard expansion: The replacement of a construct such as ‘*.c’ with a list of ‘.c’ file names. Wildcard expansion applies to an entire word at a time, and replaces that word with 0 or more file names that are themselves words.
Quote removal: The deletion of string-quotes, now that they have done their job by inhibiting the above transformations when appropriate.
For the details of these transformations, and how to write the constructs that use them, see The BASH Manual (to appear).

Next: Flags for Word Expansion, Previous: The Stages of Word Expansion, Up: Shell-Style Word Expansion   [Contents][Index]

10.4.2 Calling wordexp
All the functions, constants and data types for word expansion are declared in the header file wordexp.h.

Word expansion produces a vector of words (strings). To return this vector, wordexp uses a special data type, wordexp_t, which is a structure. You pass wordexp the address of the structure, and it fills in the structure’s fields to tell you about the results.

Data Type: wordexp_t
This data type holds a pointer to a word vector. More precisely, it records both the address of the word vector and its size.

we_wordc
The number of elements in the vector.

we_wordv
The address of the vector. This field has type char **.

we_offs
The offset of the first real element of the vector, from its nominal address in the we_wordv field. Unlike the other fields, this is always an input to wordexp, rather than an output from it.

If you use a nonzero offset, then that many elements at the beginning of the vector are left empty. (The wordexp function fills them with null pointers.)

The we_offs field is meaningful only if you use the WRDE_DOOFFS flag. Otherwise, the offset is always zero regardless of what is in this field, and the first real element comes at the beginning of the vector.

Function: int wordexp (const char *words, wordexp_t *word-vector-ptr, int flags)
Preliminary: | MT-Unsafe race:utent const:env env sig:ALRM timer locale | AS-Unsafe dlopen plugin i18n heap corrupt lock | AC-Unsafe corrupt lock fd mem | See POSIX Safety Concepts.

Perform word expansion on the string words, putting the result in a newly allocated vector, and store the size and address of this vector into *word-vector-ptr. The argument flags is a combination of bit flags; see Flags for Word Expansion, for details of the flags.

You shouldn’t use any of the characters ‘|&;<>’ in the string words unless they are quoted; likewise for newline. If you use these characters unquoted, you will get the WRDE_BADCHAR error code. Don’t use parentheses or braces unless they are quoted or part of a word expansion construct. If you use quotation characters ‘'"`’, they should come in pairs that balance.

The results of word expansion are a sequence of words. The function wordexp allocates a string for each resulting word, then allocates a vector of type char ** to store the addresses of these strings. The last element of the vector is a null pointer. This vector is called the word vector.

To return this vector, wordexp stores both its address and its length (number of elements, not counting the terminating null pointer) into *word-vector-ptr.

If wordexp succeeds, it returns 0. Otherwise, it returns one of these error codes:

WRDE_BADCHAR
The input string words contains an unquoted invalid character such as ‘|’.

WRDE_BADVAL
The input string refers to an undefined shell variable, and you used the flag WRDE_UNDEF to forbid such references.

WRDE_CMDSUB
The input string uses command substitution, and you used the flag WRDE_NOCMD to forbid command substitution.

WRDE_NOSPACE
It was impossible to allocate memory to hold the result. In this case, wordexp can store part of the results—as much as it could allocate room for.

WRDE_SYNTAX
There was a syntax error in the input string. For example, an unmatched quoting character is a syntax error. This error code is also used to signal division by zero and overflow in arithmetic expansion.

Function: void wordfree (wordexp_t *word-vector-ptr)
Preliminary: | MT-Safe | AS-Unsafe corrupt heap | AC-Unsafe corrupt mem | See POSIX Safety Concepts.

Free the storage used for the word-strings and vector that *word-vector-ptr points to. This does not free the structure *word-vector-ptr itself—only the other data it points to.

Next: wordexp Example, Previous: Calling wordexp, Up: Shell-Style Word Expansion   [Contents][Index]

10.4.3 Flags for Word Expansion
This section describes the flags that you can specify in the flags argument to wordexp. Choose the flags you want, and combine them with the C operator |.

WRDE_APPEND
Append the words from this expansion to the vector of words produced by previous calls to wordexp. This way you can effectively expand several words as if they were concatenated with spaces between them.

In order for appending to work, you must not modify the contents of the word vector structure between calls to wordexp. And, if you set WRDE_DOOFFS in the first call to wordexp, you must also set it when you append to the results.

WRDE_DOOFFS
Leave blank slots at the beginning of the vector of words. The we_offs field says how many slots to leave. The blank slots contain null pointers.

WRDE_NOCMD
Don’t do command substitution; if the input requests command substitution, report an error.

WRDE_REUSE
Reuse a word vector made by a previous call to wordexp. Instead of allocating a new vector of words, this call to wordexp will use the vector that already exists (making it larger if necessary).

Note that the vector may move, so it is not safe to save an old pointer and use it again after calling wordexp. You must fetch we_pathv anew after each call.

WRDE_SHOWERR
Do show any error messages printed by commands run by command substitution. More precisely, allow these commands to inherit the standard error output stream of the current process. By default, wordexp gives these commands a standard error stream that discards all output.

WRDE_UNDEF
If the input refers to a shell variable that is not defined, report an error.

Next: Details of Tilde Expansion, Previous: Flags for Word Expansion, Up: Shell-Style Word Expansion   [Contents][Index]

10.4.4 wordexp Example
Here is an example of using wordexp to expand several strings and use the results to run a shell command. It also shows the use of WRDE_APPEND to concatenate the expansions and of wordfree to free the space allocated by wordexp.

int
expand_and_execute (const char *program, const char **options)
{
  wordexp_t result;
  pid_t pid
  int status, i;

  /* Expand the string for the program to run.  */
  switch (wordexp (program, &result, 0))
    {
    case 0:			/* Successful.  */
      break;
    case WRDE_NOSPACE:
      /* If the error was WRDE_NOSPACE,
         then perhaps part of the result was allocated.  */
      wordfree (&result);
    default:                    /* Some other error.  */
      return -1;
    }

  /* Expand the strings specified for the arguments.  */
  for (i = 0; options[i] != NULL; i++)
    {
      if (wordexp (options[i], &result, WRDE_APPEND))
        {
          wordfree (&result);
          return -1;
        }
    }

  pid = fork ();
  if (pid == 0)
    {
      /* This is the child process.  Execute the command. */
      execv (result.we_wordv[0], result.we_wordv);
      exit (EXIT_FAILURE);
    }
  else if (pid < 0)
    /* The fork failed.  Report failure.  */
    status = -1;
  else
    /* This is the parent process.  Wait for the child to complete.  */
    if (waitpid (pid, &status, 0) != pid)
      status = -1;

  wordfree (&result);
  return status;
}
Next: Details of Variable Substitution, Previous: wordexp Example, Up: Shell-Style Word Expansion   [Contents][Index]

10.4.5 Details of Tilde Expansion
It’s a standard part of shell syntax that you can use ‘~’ at the beginning of a file name to stand for your own home directory. You can use ‘~user’ to stand for user’s home directory.

Tilde expansion is the process of converting these abbreviations to the directory names that they stand for.

Tilde expansion applies to the ‘~’ plus all following characters up to whitespace or a slash. It takes place only at the beginning of a word, and only if none of the characters to be transformed is quoted in any way.

Plain ‘~’ uses the value of the environment variable HOME as the proper home directory name. ‘~’ followed by a user name uses getpwname to look up that user in the user database, and uses whatever directory is recorded there. Thus, ‘~’ followed by your own name can give different results from plain ‘~’, if the value of HOME is not really your home directory.

Previous: Details of Tilde Expansion, Up: Shell-Style Word Expansion   [Contents][Index]

10.4.6 Details of Variable Substitution
Part of ordinary shell syntax is the use of ‘$variable’ to substitute the value of a shell variable into a command. This is called variable substitution, and it is one part of doing word expansion.

There are two basic ways you can write a variable reference for substitution:

${variable}
If you write braces around the variable name, then it is completely unambiguous where the variable name ends. You can concatenate additional letters onto the end of the variable value by writing them immediately after the close brace. For example, ‘${foo}s’ expands into ‘tractors’.

$variable
If you do not put braces around the variable name, then the variable name consists of all the alphanumeric characters and underscores that follow the ‘$’. The next punctuation character ends the variable name. Thus, ‘$foo-bar’ refers to the variable foo and expands into ‘tractor-bar’.

When you use braces, you can also use various constructs to modify the value that is substituted, or test it in various ways.

${variable:-default}
Substitute the value of variable, but if that is empty or undefined, use default instead.

${variable:=default}
Substitute the value of variable, but if that is empty or undefined, use default instead and set the variable to default.

${variable:?message}
If variable is defined and not empty, substitute its value.

Otherwise, print message as an error message on the standard error stream, and consider word expansion a failure.

${variable:+replacement}
Substitute replacement, but only if variable is defined and nonempty. Otherwise, substitute nothing for this construct.

${#variable}
Substitute a numeral which expresses in base ten the number of characters in the value of variable. ‘${#foo}’ stands for ‘7’, because ‘tractor’ is seven characters.

These variants of variable substitution let you remove part of the variable’s value before substituting it. The prefix and suffix are not mere strings; they are wildcard patterns, just like the patterns that you use to match multiple file names. But in this context, they match against parts of the variable value rather than against file names.

${variable%%suffix}
Substitute the value of variable, but first discard from that variable any portion at the end that matches the pattern suffix.

If there is more than one alternative for how to match against suffix, this construct uses the longest possible match.

Thus, ‘${foo%%r*}’ substitutes ‘t’, because the largest match for ‘r*’ at the end of ‘tractor’ is ‘ractor’.

${variable%suffix}
Substitute the value of variable, but first discard from that variable any portion at the end that matches the pattern suffix.

If there is more than one alternative for how to match against suffix, this construct uses the shortest possible alternative.

Thus, ‘${foo%r*}’ substitutes ‘tracto’, because the shortest match for ‘r*’ at the end of ‘tractor’ is just ‘r’.

${variable##prefix}
Substitute the value of variable, but first discard from that variable any portion at the beginning that matches the pattern prefix.

If there is more than one alternative for how to match against prefix, this construct uses the longest possible match.

Thus, ‘${foo##*t}’ substitutes ‘or’, because the largest match for ‘*t’ at the beginning of ‘tractor’ is ‘tract’.

${variable#prefix}
Substitute the value of variable, but first discard from that variable any portion at the beginning that matches the pattern prefix.

If there is more than one alternative for how to match against prefix, this construct uses the shortest possible alternative.

Thus, ‘${foo#*t}’ substitutes ‘ractor’, because the shortest match for ‘*t’ at the beginning of ‘tractor’ is just ‘t’.

Next: Input/Output on Streams, Previous: Pattern Matching, Up: Main Menu   [Contents][Index]

11 Input/Output Overview
Most programs need to do either input (reading data) or output (writing data), or most frequently both, in order to do anything useful. The GNU C Library provides such a large selection of input and output functions that the hardest part is often deciding which function is most appropriate!

This chapter introduces concepts and terminology relating to input and output. Other chapters relating to the GNU I/O facilities are:

Input/Output on Streams, which covers the high-level functions that operate on streams, including formatted input and output.
Low-Level Input/Output, which covers the basic I/O and control functions on file descriptors.
File System Interface, which covers functions for operating on directories and for manipulating file attributes such as access modes and ownership.
Pipes and FIFOs, which includes information on the basic interprocess communication facilities.
Sockets, which covers a more complicated interprocess communication facility with support for networking.
Low-Level Terminal Interface, which covers functions for changing how input and output to terminals or other serial devices are processed.
Input/Output Concepts
File Names
Next: File Names, Up: Input/Output Overview   [Contents][Index]

11.1 Input/Output Concepts
Before you can read or write the contents of a file, you must establish a connection or communications channel to the file. This process is called opening the file. You can open a file for reading, writing, or both.

The connection to an open file is represented either as a stream or as a file descriptor. You pass this as an argument to the functions that do the actual read or write operations, to tell them which file to operate on. Certain functions expect streams, and others are designed to operate on file descriptors.

When you have finished reading to or writing from the file, you can terminate the connection by closing the file. Once you have closed a stream or file descriptor, you cannot do any more input or output operations on it.

Streams and File Descriptors
File Position
Next: File Position, Up: Input/Output Concepts   [Contents][Index]

11.1.1 Streams and File Descriptors
When you want to do input or output to a file, you have a choice of two basic mechanisms for representing the connection between your program and the file: file descriptors and streams. File descriptors are represented as objects of type int, while streams are represented as FILE * objects.

File descriptors provide a primitive, low-level interface to input and output operations. Both file descriptors and streams can represent a connection to a device (such as a terminal), or a pipe or socket for communicating with another process, as well as a normal file. But, if you want to do control operations that are specific to a particular kind of device, you must use a file descriptor; there are no facilities to use streams in this way. You must also use file descriptors if your program needs to do input or output in special modes, such as nonblocking (or polled) input (see File Status Flags).

Streams provide a higher-level interface, layered on top of the primitive file descriptor facilities. The stream interface treats all kinds of files pretty much alike—the sole exception being the three styles of buffering that you can choose (see Stream Buffering).

The main advantage of using the stream interface is that the set of functions for performing actual input and output operations (as opposed to control operations) on streams is much richer and more powerful than the corresponding facilities for file descriptors. The file descriptor interface provides only simple functions for transferring blocks of characters, but the stream interface also provides powerful formatted input and output functions (printf and scanf) as well as functions for character- and line-oriented input and output.

Since streams are implemented in terms of file descriptors, you can extract the file descriptor from a stream and perform low-level operations directly on the file descriptor. You can also initially open a connection as a file descriptor and then make a stream associated with that file descriptor.

In general, you should stick with using streams rather than file descriptors, unless there is some specific operation you want to do that can only be done on a file descriptor. If you are a beginning programmer and aren’t sure what functions to use, we suggest that you concentrate on the formatted input functions (see Formatted Input) and formatted output functions (see Formatted Output).

If you are concerned about portability of your programs to systems other than GNU, you should also be aware that file descriptors are not as portable as streams. You can expect any system running ISO C to support streams, but non-GNU systems may not support file descriptors at all, or may only implement a subset of the GNU functions that operate on file descriptors. Most of the file descriptor functions in the GNU C Library are included in the POSIX.1 standard, however.

Previous: Streams and File Descriptors, Up: Input/Output Concepts   [Contents][Index]

11.1.2 File Position
One of the attributes of an open file is its file position that keeps track of where in the file the next character is to be read or written. On GNU systems, and all POSIX.1 systems, the file position is simply an integer representing the number of bytes from the beginning of the file.

The file position is normally set to the beginning of the file when it is opened, and each time a character is read or written, the file position is incremented. In other words, access to the file is normally sequential.

Ordinary files permit read or write operations at any position within the file. Some other kinds of files may also permit this. Files which do permit this are sometimes referred to as random-access files. You can change the file position using the fseek function on a stream (see File Positioning) or the lseek function on a file descriptor (see Input and Output Primitives). If you try to change the file position on a file that doesn’t support random access, you get the ESPIPE error.

Streams and descriptors that are opened for append access are treated specially for output: output to such files is always appended sequentially to the end of the file, regardless of the file position. However, the file position is still used to control where in the file reading is done.

If you think about it, you’ll realize that several programs can read a given file at the same time. In order for each program to be able to read the file at its own pace, each program must have its own file pointer, which is not affected by anything the other programs do.

In fact, each opening of a file creates a separate file position. Thus, if you open a file twice even in the same program, you get two streams or descriptors with independent file positions.

By contrast, if you open a descriptor and then duplicate it to get another descriptor, these two descriptors share the same file position: changing the file position of one descriptor will affect the other.

Previous: Input/Output Concepts, Up: Input/Output Overview   [Contents][Index]

11.2 File Names
In order to open a connection to a file, or to perform other operations such as deleting a file, you need some way to refer to the file. Nearly all files have names that are strings—even files which are actually devices such as tape drives or terminals. These strings are called file names. You specify the file name to say which file you want to open or operate on.

This section describes the conventions for file names and how the operating system works with them.

Directories
File Name Resolution
File Name Errors
Portability of File Names
Next: File Name Resolution, Up: File Names   [Contents][Index]

11.2.1 Directories
In order to understand the syntax of file names, you need to understand how the file system is organized into a hierarchy of directories.

A directory is a file that contains information to associate other files with names; these associations are called links or directory entries. Sometimes, people speak of “files in a directory”, but in reality, a directory only contains pointers to files, not the files themselves.

The name of a file contained in a directory entry is called a file name component. In general, a file name consists of a sequence of one or more such components, separated by the slash character (‘/’). A file name which is just one component names a file with respect to its directory. A file name with multiple components names a directory, and then a file in that directory, and so on.

Some other documents, such as the POSIX standard, use the term pathname for what we call a file name, and either filename or pathname component for what this manual calls a file name component. We don’t use this terminology because a “path” is something completely different (a list of directories to search), and we think that “pathname” used for something else will confuse users. We always use “file name” and “file name component” (or sometimes just “component”, where the context is obvious) in GNU documentation. Some macros use the POSIX terminology in their names, such as PATH_MAX. These macros are defined by the POSIX standard, so we cannot change their names.

You can find more detailed information about operations on directories in File System Interface.

Next: File Name Errors, Previous: Directories, Up: File Names   [Contents][Index]

11.2.2 File Name Resolution
A file name consists of file name components separated by slash (‘/’) characters. On the systems that the GNU C Library supports, multiple successive ‘/’ characters are equivalent to a single ‘/’ character.

The process of determining what file a file name refers to is called file name resolution. This is performed by examining the components that make up a file name in left-to-right order, and locating each successive component in the directory named by the previous component. Of course, each of the files that are referenced as directories must actually exist, be directories instead of regular files, and have the appropriate permissions to be accessible by the process; otherwise the file name resolution fails.

If a file name begins with a ‘/’, the first component in the file name is located in the root directory of the process (usually all processes on the system have the same root directory). Such a file name is called an absolute file name.

Otherwise, the first component in the file name is located in the current working directory (see Working Directory). This kind of file name is called a relative file name.

The file name components . (“dot”) and .. (“dot-dot”) have special meanings. Every directory has entries for these file name components. The file name component . refers to the directory itself, while the file name component .. refers to its parent directory (the directory that contains the link for the directory in question). As a special case, .. in the root directory refers to the root directory itself, since it has no parent; thus /.. is the same as /.

Here are some examples of file names:

/a
The file named a, in the root directory.

/a/b
The file named b, in the directory named a in the root directory.

a
The file named a, in the current working directory.

/a/./b
This is the same as /a/b.

./a
The file named a, in the current working directory.

../a
The file named a, in the parent directory of the current working directory.

A file name that names a directory may optionally end in a ‘/’. You can specify a file name of / to refer to the root directory, but the empty string is not a meaningful file name. If you want to refer to the current working directory, use a file name of . or ./.

Unlike some other operating systems, GNU systems don’t have any built-in support for file types (or extensions) or file versions as part of its file name syntax. Many programs and utilities use conventions for file names—for example, files containing C source code usually have names suffixed with ‘.c’—but there is nothing in the file system itself that enforces this kind of convention.

Next: Portability of File Names, Previous: File Name Resolution, Up: File Names   [Contents][Index]

11.2.3 File Name Errors
Functions that accept file name arguments usually detect these errno error conditions relating to the file name syntax or trouble finding the named file. These errors are referred to throughout this manual as the usual file name errors.

EACCES
The process does not have search permission for a directory component of the file name.

ENAMETOOLONG
This error is used when either the total length of a file name is greater than PATH_MAX, or when an individual file name component has a length greater than NAME_MAX. See Limits on File System Capacity.

On GNU/Hurd systems, there is no imposed limit on overall file name length, but some file systems may place limits on the length of a component.

ENOENT
This error is reported when a file referenced as a directory component in the file name doesn’t exist, or when a component is a symbolic link whose target file does not exist. See Symbolic Links.

ENOTDIR
A file that is referenced as a directory component in the file name exists, but it isn’t a directory.

ELOOP
Too many symbolic links were resolved while trying to look up the file name. The system has an arbitrary limit on the number of symbolic links that may be resolved in looking up a single file name, as a primitive way to detect loops. See Symbolic Links.

Previous: File Name Errors, Up: File Names   [Contents][Index]

11.2.4 Portability of File Names
The rules for the syntax of file names discussed in File Names, are the rules normally used by GNU systems and by other POSIX systems. However, other operating systems may use other conventions.

There are two reasons why it can be important for you to be aware of file name portability issues:

If your program makes assumptions about file name syntax, or contains embedded literal file name strings, it is more difficult to get it to run under other operating systems that use different syntax conventions.
Even if you are not concerned about running your program on machines that run other operating systems, it may still be possible to access files that use different naming conventions. For example, you may be able to access file systems on another computer running a different operating system over a network, or read and write disks in formats used by other operating systems.
The ISO C standard says very little about file name syntax, only that file names are strings. In addition to varying restrictions on the length of file names and what characters can validly appear in a file name, different operating systems use different conventions and syntax for concepts such as structured directories and file types or extensions. Some concepts such as file versions might be supported in some operating systems and not by others.

The POSIX.1 standard allows implementations to put additional restrictions on file name syntax, concerning what characters are permitted in file names and on the length of file name and file name component strings. However, on GNU systems, any character except the null character is permitted in a file name string, and on GNU/Hurd systems there are no limits on the length of file name strings.

Next: Low-Level Input/Output, Previous: Input/Output Overview, Up: Main Menu   [Contents][Index]

12 Input/Output on Streams
This chapter describes the functions for creating streams and performing input and output operations on them. As discussed in Input/Output Overview, a stream is a fairly abstract, high-level concept representing a communications channel to a file, device, or process.

Streams
Standard Streams
Opening Streams
Closing Streams
Streams and Threads
Streams in Internationalized Applications
Simple Output by Characters or Lines
Character Input
Line-Oriented Input
Unreading
Block Input/Output
Formatted Output
Customizing printf
Formatted Input
End-Of-File and Errors
Recovering from errors
Text and Binary Streams
File Positioning
Portable File-Position Functions
Stream Buffering
Other Kinds of Streams
Formatted Messages
Next: Standard Streams, Up: Input/Output on Streams   [Contents][Index]

12.1 Streams
For historical reasons, the type of the C data structure that represents a stream is called FILE rather than “stream”. Since most of the library functions deal with objects of type FILE *, sometimes the term file pointer is also used to mean “stream”. This leads to unfortunate confusion over terminology in many books on C. This manual, however, is careful to use the terms “file” and “stream” only in the technical sense.

The FILE type is declared in the header file stdio.h.

Data Type: FILE
This is the data type used to represent stream objects. A FILE object holds all of the internal state information about the connection to the associated file, including such things as the file position indicator and buffering information. Each stream also has error and end-of-file status indicators that can be tested with the ferror and feof functions; see End-Of-File and Errors.

FILE objects are allocated and managed internally by the input/output library functions. Don’t try to create your own objects of type FILE; let the library do it. Your programs should deal only with pointers to these objects (that is, FILE * values) rather than the objects themselves.

Next: Opening Streams, Previous: Streams, Up: Input/Output on Streams   [Contents][Index]

12.2 Standard Streams
When the main function of your program is invoked, it already has three predefined streams open and available for use. These represent the “standard” input and output channels that have been established for the process.

These streams are declared in the header file stdio.h.

Variable: FILE * stdin
The standard input stream, which is the normal source of input for the program.

Variable: FILE * stdout
The standard output stream, which is used for normal output from the program.

Variable: FILE * stderr
The standard error stream, which is used for error messages and diagnostics issued by the program.

On GNU systems, you can specify what files or processes correspond to these streams using the pipe and redirection facilities provided by the shell. (The primitives shells use to implement these facilities are described in File System Interface.) Most other operating systems provide similar mechanisms, but the details of how to use them can vary.

In the GNU C Library, stdin, stdout, and stderr are normal variables which you can set just like any others. For example, to redirect the standard output to a file, you could do:

fclose (stdout);
stdout = fopen ("standard-output-file", "w");
Note however, that in other systems stdin, stdout, and stderr are macros that you cannot assign to in the normal way. But you can use freopen to get the effect of closing one and reopening it. See Opening Streams.

The three streams stdin, stdout, and stderr are not unoriented at program start (see Streams in Internationalized Applications).

Next: Closing Streams, Previous: Standard Streams, Up: Input/Output on Streams   [Contents][Index]

12.3 Opening Streams
Opening a file with the fopen function creates a new stream and establishes a connection between the stream and a file. This may involve creating a new file.

Everything described in this section is declared in the header file stdio.h.

Function: FILE * fopen (const char *filename, const char *opentype)
Preliminary: | MT-Safe | AS-Unsafe heap lock | AC-Unsafe mem fd lock | See POSIX Safety Concepts.

The fopen function opens a stream for I/O to the file filename, and returns a pointer to the stream.

The opentype argument is a string that controls how the file is opened and specifies attributes of the resulting stream. It must begin with one of the following sequences of characters:

‘r’
Open an existing file for reading only.

‘w’
Open the file for writing only. If the file already exists, it is truncated to zero length. Otherwise a new file is created.

‘a’
Open a file for append access; that is, writing at the end of file only. If the file already exists, its initial contents are unchanged and output to the stream is appended to the end of the file. Otherwise, a new, empty file is created.

‘r+’
Open an existing file for both reading and writing. The initial contents of the file are unchanged and the initial file position is at the beginning of the file.

‘w+’
Open a file for both reading and writing. If the file already exists, it is truncated to zero length. Otherwise, a new file is created.

‘a+’
Open or create file for both reading and appending. If the file exists, its initial contents are unchanged. Otherwise, a new file is created. The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file.

As you can see, ‘+’ requests a stream that can do both input and output. When using such a stream, you must call fflush (see Stream Buffering) or a file positioning function such as fseek (see File Positioning) when switching from reading to writing or vice versa. Otherwise, internal buffers might not be emptied properly.

Additional characters may appear after these to specify flags for the call. Always put the mode (‘r’, ‘w+’, etc.) first; that is the only part you are guaranteed will be understood by all systems.

The GNU C Library defines additional characters for use in opentype:

‘c’
The file is opened with cancellation in the I/O functions disabled.

‘e’
The underlying file descriptor will be closed if you use any of the exec… functions (see Executing a File). (This is equivalent to having set FD_CLOEXEC on that descriptor. See File Descriptor Flags.)

‘m’
The file is opened and accessed using mmap. This is only supported with files opened for reading.

‘x’
Insist on creating a new file—if a file filename already exists, fopen fails rather than opening it. If you use ‘x’ you are guaranteed that you will not clobber an existing file. This is equivalent to the O_EXCL option to the open function (see Opening and Closing Files).

The ‘x’ modifier is part of ISO C11, which says the file is created with exclusive access; in the GNU C Library this means the equivalent of O_EXCL.

The character ‘b’ in opentype has a standard meaning; it requests a binary stream rather than a text stream. But this makes no difference in POSIX systems (including GNU systems). If both ‘+’ and ‘b’ are specified, they can appear in either order. See Text and Binary Streams.

If the opentype string contains the sequence ,ccs=STRING then STRING is taken as the name of a coded character set and fopen will mark the stream as wide-oriented with appropriate conversion functions in place to convert from and to the character set STRING. Any other stream is opened initially unoriented and the orientation is decided with the first file operation. If the first operation is a wide character operation, the stream is not only marked as wide-oriented, also the conversion functions to convert to the coded character set used for the current locale are loaded. This will not change anymore from this point on even if the locale selected for the LC_CTYPE category is changed.

Any other characters in opentype are simply ignored. They may be meaningful in other systems.

If the open fails, fopen returns a null pointer.

When the sources are compiled with _FILE_OFFSET_BITS == 64 on a 32 bit machine this function is in fact fopen64 since the LFS interface replaces transparently the old interface.

You can have multiple streams (or file descriptors) pointing to the same file open at the same time. If you do only input, this works straightforwardly, but you must be careful if any output streams are included. See Dangers of Mixing Streams and Descriptors. This is equally true whether the streams are in one program (not usual) or in several programs (which can easily happen). It may be advantageous to use the file locking facilities to avoid simultaneous access. See File Locks.

Function: FILE * fopen64 (const char *filename, const char *opentype)
Preliminary: | MT-Safe | AS-Unsafe heap lock | AC-Unsafe mem fd lock | See POSIX Safety Concepts.

This function is similar to fopen but the stream it returns a pointer for is opened using open64. Therefore this stream can be used even on files larger than 2^31 bytes on 32 bit machines.

Please note that the return type is still FILE *. There is no special FILE type for the LFS interface.

If the sources are compiled with _FILE_OFFSET_BITS == 64 on a 32 bits machine this function is available under the name fopen and so transparently replaces the old interface.

Macro: int FOPEN_MAX
The value of this macro is an integer constant expression that represents the minimum number of streams that the implementation guarantees can be open simultaneously. You might be able to open more than this many streams, but that is not guaranteed. The value of this constant is at least eight, which includes the three standard streams stdin, stdout, and stderr. In POSIX.1 systems this value is determined by the OPEN_MAX parameter; see General Capacity Limits. In BSD and GNU, it is controlled by the RLIMIT_NOFILE resource limit; see Limiting Resource Usage.

Function: FILE * freopen (const char *filename, const char *opentype, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt fd | See POSIX Safety Concepts.

This function is like a combination of fclose and fopen. It first closes the stream referred to by stream, ignoring any errors that are detected in the process. (Because errors are ignored, you should not use freopen on an output stream if you have actually done any output using the stream.) Then the file named by filename is opened with mode opentype as for fopen, and associated with the same stream object stream.

If the operation fails, a null pointer is returned; otherwise, freopen returns stream. On Linux, freopen may also fail and set errno to EBUSY when the kernel structure for the old file descriptor was not initialized completely before freopen was called. This can only happen in multi-threaded programs, when two threads race to allocate the same file descriptor number. To avoid the possibility of this race, do not use close to close the underlying file descriptor for a FILE; either use freopen while the file is still open, or use open and then dup2 to install the new file descriptor.

freopen has traditionally been used to connect a standard stream such as stdin with a file of your own choice. This is useful in programs in which use of a standard stream for certain purposes is hard-coded. In the GNU C Library, you can simply close the standard streams and open new ones with fopen. But other systems lack this ability, so using freopen is more portable.

When the sources are compiled with _FILE_OFFSET_BITS == 64 on a 32 bit machine this function is in fact freopen64 since the LFS interface replaces transparently the old interface.

Function: FILE * freopen64 (const char *filename, const char *opentype, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt fd | See POSIX Safety Concepts.

This function is similar to freopen. The only difference is that on 32 bit machine the stream returned is able to read beyond the 2^31 bytes limits imposed by the normal interface. It should be noted that the stream pointed to by stream need not be opened using fopen64 or freopen64 since its mode is not important for this function.

If the sources are compiled with _FILE_OFFSET_BITS == 64 on a 32 bits machine this function is available under the name freopen and so transparently replaces the old interface.

In some situations it is useful to know whether a given stream is available for reading or writing. This information is normally not available and would have to be remembered separately. Solaris introduced a few functions to get this information from the stream descriptor and these functions are also available in the GNU C Library.

Function: int __freadable (FILE *stream)
Preliminary: | MT-Safe | AS-Safe | AC-Safe | See POSIX Safety Concepts.

The __freadable function determines whether the stream stream was opened to allow reading. In this case the return value is nonzero. For write-only streams the function returns zero.

This function is declared in stdio_ext.h.

Function: int __fwritable (FILE *stream)
Preliminary: | MT-Safe | AS-Safe | AC-Safe | See POSIX Safety Concepts.

The __fwritable function determines whether the stream stream was opened to allow writing. In this case the return value is nonzero. For read-only streams the function returns zero.

This function is declared in stdio_ext.h.

For slightly different kinds of problems there are two more functions. They provide even finer-grained information.

Function: int __freading (FILE *stream)
Preliminary: | MT-Safe | AS-Safe | AC-Safe | See POSIX Safety Concepts.

The __freading function determines whether the stream stream was last read from or whether it is opened read-only. In this case the return value is nonzero, otherwise it is zero. Determining whether a stream opened for reading and writing was last used for writing allows to draw conclusions about the content about the buffer, among other things.

This function is declared in stdio_ext.h.

Function: int __fwriting (FILE *stream)
Preliminary: | MT-Safe | AS-Safe | AC-Safe | See POSIX Safety Concepts.

The __fwriting function determines whether the stream stream was last written to or whether it is opened write-only. In this case the return value is nonzero, otherwise it is zero.

This function is declared in stdio_ext.h.

Next: Streams and Threads, Previous: Opening Streams, Up: Input/Output on Streams   [Contents][Index]

12.4 Closing Streams
When a stream is closed with fclose, the connection between the stream and the file is canceled. After you have closed a stream, you cannot perform any additional operations on it.

Function: int fclose (FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe heap lock | AC-Unsafe lock mem fd | See POSIX Safety Concepts.

This function causes stream to be closed and the connection to the corresponding file to be broken. Any buffered output is written and any buffered input is discarded. The fclose function returns a value of 0 if the file was closed successfully, and EOF if an error was detected.

It is important to check for errors when you call fclose to close an output stream, because real, everyday errors can be detected at this time. For example, when fclose writes the remaining buffered output, it might get an error because the disk is full. Even if you know the buffer is empty, errors can still occur when closing a file if you are using NFS.

The function fclose is declared in stdio.h.

To close all streams currently available the GNU C Library provides another function.

Function: int fcloseall (void)
Preliminary: | MT-Unsafe race:streams | AS-Unsafe | AC-Safe | See POSIX Safety Concepts.

This function causes all open streams of the process to be closed and the connections to corresponding files to be broken. All buffered data is written and any buffered input is discarded. The fcloseall function returns a value of 0 if all the files were closed successfully, and EOF if an error was detected.

This function should be used only in special situations, e.g., when an error occurred and the program must be aborted. Normally each single stream should be closed separately so that problems with individual streams can be identified. It is also problematic since the standard streams (see Standard Streams) will also be closed.

The function fcloseall is declared in stdio.h.

If the main function to your program returns, or if you call the exit function (see Normal Termination), all open streams are automatically closed properly. If your program terminates in any other manner, such as by calling the abort function (see Aborting a Program) or from a fatal signal (see Signal Handling), open streams might not be closed properly. Buffered output might not be flushed and files may be incomplete. For more information on buffering of streams, see Stream Buffering.

Next: Streams in Internationalized Applications, Previous: Closing Streams, Up: Input/Output on Streams   [Contents][Index]

12.5 Streams and Threads
Streams can be used in multi-threaded applications in the same way they are used in single-threaded applications. But the programmer must be aware of the possible complications. It is important to know about these also if the program one writes never use threads since the design and implementation of many stream functions are heavily influenced by the requirements added by multi-threaded programming.

The POSIX standard requires that by default the stream operations are atomic. I.e., issuing two stream operations for the same stream in two threads at the same time will cause the operations to be executed as if they were issued sequentially. The buffer operations performed while reading or writing are protected from other uses of the same stream. To do this each stream has an internal lock object which has to be (implicitly) acquired before any work can be done.

But there are situations where this is not enough and there are also situations where this is not wanted. The implicit locking is not enough if the program requires more than one stream function call to happen atomically. One example would be if an output line a program wants to generate is created by several function calls. The functions by themselves would ensure only atomicity of their own operation, but not atomicity over all the function calls. For this it is necessary to perform the stream locking in the application code.

Function: void flockfile (FILE *stream)
Preliminary: | MT-Safe | AS-Safe | AC-Unsafe lock | See POSIX Safety Concepts.

The flockfile function acquires the internal locking object associated with the stream stream. This ensures that no other thread can explicitly through flockfile/ftrylockfile or implicitly through the call of a stream function lock the stream. The thread will block until the lock is acquired. An explicit call to funlockfile has to be used to release the lock.

Function: int ftrylockfile (FILE *stream)
Preliminary: | MT-Safe | AS-Safe | AC-Unsafe lock | See POSIX Safety Concepts.

The ftrylockfile function tries to acquire the internal locking object associated with the stream stream just like flockfile. But unlike flockfile this function does not block if the lock is not available. ftrylockfile returns zero if the lock was successfully acquired. Otherwise the stream is locked by another thread.

Function: void funlockfile (FILE *stream)
Preliminary: | MT-Safe | AS-Safe | AC-Unsafe lock | See POSIX Safety Concepts.

The funlockfile function releases the internal locking object of the stream stream. The stream must have been locked before by a call to flockfile or a successful call of ftrylockfile. The implicit locking performed by the stream operations do not count. The funlockfile function does not return an error status and the behavior of a call for a stream which is not locked by the current thread is undefined.

The following example shows how the functions above can be used to generate an output line atomically even in multi-threaded applications (yes, the same job could be done with one fprintf call but it is sometimes not possible):

FILE *fp;
{
   …
   flockfile (fp);
   fputs ("This is test number ", fp);
   fprintf (fp, "%d\n", test);
   funlockfile (fp)
}
Without the explicit locking it would be possible for another thread to use the stream fp after the fputs call returns and before fprintf was called with the result that the number does not follow the word ‘number’.

From this description it might already be clear that the locking objects in streams are no simple mutexes. Since locking the same stream twice in the same thread is allowed the locking objects must be equivalent to recursive mutexes. These mutexes keep track of the owner and the number of times the lock is acquired. The same number of funlockfile calls by the same threads is necessary to unlock the stream completely. For instance:

void
foo (FILE *fp)
{
  ftrylockfile (fp);
  fputs ("in foo\n", fp);
  /* This is very wrong!!!  */
  funlockfile (fp);
}
It is important here that the funlockfile function is only called if the ftrylockfile function succeeded in locking the stream. It is therefore always wrong to ignore the result of ftrylockfile. And it makes no sense since otherwise one would use flockfile. The result of code like that above is that either funlockfile tries to free a stream that hasn’t been locked by the current thread or it frees the stream prematurely. The code should look like this:

void
foo (FILE *fp)
{
  if (ftrylockfile (fp) == 0)
    {
      fputs ("in foo\n", fp);
      funlockfile (fp);
    }
}
Now that we covered why it is necessary to have locking it is necessary to talk about situations when locking is unwanted and what can be done. The locking operations (explicit or implicit) don’t come for free. Even if a lock is not taken the cost is not zero. The operations which have to be performed require memory operations that are safe in multi-processor environments. With the many local caches involved in such systems this is quite costly. So it is best to avoid the locking completely if it is not needed – because the code in question is never used in a context where two or more threads may use a stream at a time. This can be determined most of the time for application code; for library code which can be used in many contexts one should default to be conservative and use locking.

There are two basic mechanisms to avoid locking. The first is to use the _unlocked variants of the stream operations. The POSIX standard defines quite a few of those and the GNU C Library adds a few more. These variants of the functions behave just like the functions with the name without the suffix except that they do not lock the stream. Using these functions is very desirable since they are potentially much faster. This is not only because the locking operation itself is avoided. More importantly, functions like putc and getc are very simple and traditionally (before the introduction of threads) were implemented as macros which are very fast if the buffer is not empty. With the addition of locking requirements these functions are no longer implemented as macros since they would expand to too much code. But these macros are still available with the same functionality under the new names putc_unlocked and getc_unlocked. This possibly huge difference of speed also suggests the use of the _unlocked functions even if locking is required. The difference is that the locking then has to be performed in the program:

void
foo (FILE *fp, char *buf)
{
  flockfile (fp);
  while (*buf != '/')
    putc_unlocked (*buf++, fp);
  funlockfile (fp);
}
If in this example the putc function would be used and the explicit locking would be missing the putc function would have to acquire the lock in every call, potentially many times depending on when the loop terminates. Writing it the way illustrated above allows the putc_unlocked macro to be used which means no locking and direct manipulation of the buffer of the stream.

A second way to avoid locking is by using a non-standard function which was introduced in Solaris and is available in the GNU C Library as well.

Function: int __fsetlocking (FILE *stream, int type)
Preliminary: | MT-Safe race:stream | AS-Unsafe lock | AC-Safe | See POSIX Safety Concepts.

The __fsetlocking function can be used to select whether the stream operations will implicitly acquire the locking object of the stream stream. By default this is done but it can be disabled and reinstated using this function. There are three values defined for the type parameter.

FSETLOCKING_INTERNAL
The stream stream will from now on use the default internal locking. Every stream operation with exception of the _unlocked variants will implicitly lock the stream.

FSETLOCKING_BYCALLER
After the __fsetlocking function returns, the user is responsible for locking the stream. None of the stream operations will implicitly do this anymore until the state is set back to FSETLOCKING_INTERNAL.

FSETLOCKING_QUERY
__fsetlocking only queries the current locking state of the stream. The return value will be FSETLOCKING_INTERNAL or FSETLOCKING_BYCALLER depending on the state.

The return value of __fsetlocking is either FSETLOCKING_INTERNAL or FSETLOCKING_BYCALLER depending on the state of the stream before the call.

This function and the values for the type parameter are declared in stdio_ext.h.

This function is especially useful when program code has to be used which is written without knowledge about the _unlocked functions (or if the programmer was too lazy to use them).

Next: Simple Output by Characters or Lines, Previous: Streams and Threads, Up: Input/Output on Streams   [Contents][Index]

12.6 Streams in Internationalized Applications
ISO C90 introduced the new type wchar_t to allow handling larger character sets. What was missing was a possibility to output strings of wchar_t directly. One had to convert them into multibyte strings using mbstowcs (there was no mbsrtowcs yet) and then use the normal stream functions. While this is doable it is very cumbersome since performing the conversions is not trivial and greatly increases program complexity and size.

The Unix standard early on (I think in XPG4.2) introduced two additional format specifiers for the printf and scanf families of functions. Printing and reading of single wide characters was made possible using the %C specifier and wide character strings can be handled with %S. These modifiers behave just like %c and %s only that they expect the corresponding argument to have the wide character type and that the wide character and string are transformed into/from multibyte strings before being used.

This was a beginning but it is still not good enough. Not always is it desirable to use printf and scanf. The other, smaller and faster functions cannot handle wide characters. Second, it is not possible to have a format string for printf and scanf consisting of wide characters. The result is that format strings would have to be generated if they have to contain non-basic characters.

In the Amendment 1 to ISO C90 a whole new set of functions was added to solve the problem. Most of the stream functions got a counterpart which take a wide character or wide character string instead of a character or string respectively. The new functions operate on the same streams (like stdout). This is different from the model of the C++ runtime library where separate streams for wide and normal I/O are used.

Being able to use the same stream for wide and normal operations comes with a restriction: a stream can be used either for wide operations or for normal operations. Once it is decided there is no way back. Only a call to freopen or freopen64 can reset the orientation. The orientation can be decided in three ways:

If any of the normal character functions are used (this includes the fread and fwrite functions) the stream is marked as not wide oriented.
If any of the wide character functions are used the stream is marked as wide oriented.
The fwide function can be used to set the orientation either way.
It is important to never mix the use of wide and not wide operations on a stream. There are no diagnostics issued. The application behavior will simply be strange or the application will simply crash. The fwide function can help avoid this.

Function: int fwide (FILE *stream, int mode)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock | See POSIX Safety Concepts.

The fwide function can be used to set and query the state of the orientation of the stream stream. If the mode parameter has a positive value the streams get wide oriented, for negative values narrow oriented. It is not possible to overwrite previous orientations with fwide. I.e., if the stream stream was already oriented before the call nothing is done.

If mode is zero the current orientation state is queried and nothing is changed.

The fwide function returns a negative value, zero, or a positive value if the stream is narrow, not at all, or wide oriented respectively.

This function was introduced in Amendment 1 to ISO C90 and is declared in wchar.h.

It is generally a good idea to orient a stream as early as possible. This can prevent surprise especially for the standard streams stdin, stdout, and stderr. If some library function in some situations uses one of these streams and this use orients the stream in a different way the rest of the application expects it one might end up with hard to reproduce errors. Remember that no errors are signal if the streams are used incorrectly. Leaving a stream unoriented after creation is normally only necessary for library functions which create streams which can be used in different contexts.

When writing code which uses streams and which can be used in different contexts it is important to query the orientation of the stream before using it (unless the rules of the library interface demand a specific orientation). The following little, silly function illustrates this.

void
print_f (FILE *fp)
{
  if (fwide (fp, 0) > 0)
    /* Positive return value means wide orientation.  */
    fputwc (L'f', fp);
  else
    fputc ('f', fp);
}
Note that in this case the function print_f decides about the orientation of the stream if it was unoriented before (will not happen if the advice above is followed).

The encoding used for the wchar_t values is unspecified and the user must not make any assumptions about it. For I/O of wchar_t values this means that it is impossible to write these values directly to the stream. This is not what follows from the ISO C locale model either. What happens instead is that the bytes read from or written to the underlying media are first converted into the internal encoding chosen by the implementation for wchar_t. The external encoding is determined by the LC_CTYPE category of the current locale or by the ‘ccs’ part of the mode specification given to fopen, fopen64, freopen, or freopen64. How and when the conversion happens is unspecified and it happens invisibly to the user.

Since a stream is created in the unoriented state it has at that point no conversion associated with it. The conversion which will be used is determined by the LC_CTYPE category selected at the time the stream is oriented. If the locales are changed at the runtime this might produce surprising results unless one pays attention. This is just another good reason to orient the stream explicitly as soon as possible, perhaps with a call to fwide.

Next: Character Input, Previous: Streams in Internationalized Applications, Up: Input/Output on Streams   [Contents][Index]

12.7 Simple Output by Characters or Lines
This section describes functions for performing character- and line-oriented output.

These narrow stream functions are declared in the header file stdio.h and the wide stream functions in wchar.h.

Function: int fputc (int c, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

The fputc function converts the character c to type unsigned char, and writes it to the stream stream. EOF is returned if a write error occurs; otherwise the character c is returned.

Function: wint_t fputwc (wchar_t wc, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

The fputwc function writes the wide character wc to the stream stream. WEOF is returned if a write error occurs; otherwise the character wc is returned.

Function: int fputc_unlocked (int c, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fputc_unlocked function is equivalent to the fputc function except that it does not implicitly lock the stream.

Function: wint_t fputwc_unlocked (wchar_t wc, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fputwc_unlocked function is equivalent to the fputwc function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: int putc (int c, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

This is just like fputc, except that most systems implement it as a macro, making it faster. One consequence is that it may evaluate the stream argument more than once, which is an exception to the general rule for macros. putc is usually the best function to use for writing a single character.

Function: wint_t putwc (wchar_t wc, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

This is just like fputwc, except that it can be implement as a macro, making it faster. One consequence is that it may evaluate the stream argument more than once, which is an exception to the general rule for macros. putwc is usually the best function to use for writing a single wide character.

Function: int putc_unlocked (int c, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The putc_unlocked function is equivalent to the putc function except that it does not implicitly lock the stream.

Function: wint_t putwc_unlocked (wchar_t wc, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The putwc_unlocked function is equivalent to the putwc function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: int putchar (int c)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

The putchar function is equivalent to putc with stdout as the value of the stream argument.

Function: wint_t putwchar (wchar_t wc)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

The putwchar function is equivalent to putwc with stdout as the value of the stream argument.

Function: int putchar_unlocked (int c)
Preliminary: | MT-Unsafe race:stdout | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The putchar_unlocked function is equivalent to the putchar function except that it does not implicitly lock the stream.

Function: wint_t putwchar_unlocked (wchar_t wc)
Preliminary: | MT-Unsafe race:stdout | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The putwchar_unlocked function is equivalent to the putwchar function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: int fputs (const char *s, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

The function fputs writes the string s to the stream stream. The terminating null character is not written. This function does not add a newline character, either. It outputs only the characters in the string.

This function returns EOF if a write error occurs, and otherwise a non-negative value.

For example:

fputs ("Are ", stdout);
fputs ("you ", stdout);
fputs ("hungry?\n", stdout);
outputs the text ‘Are you hungry?’ followed by a newline.

Function: int fputws (const wchar_t *ws, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock | See POSIX Safety Concepts.

The function fputws writes the wide character string ws to the stream stream. The terminating null character is not written. This function does not add a newline character, either. It outputs only the characters in the string.

This function returns WEOF if a write error occurs, and otherwise a non-negative value.

Function: int fputs_unlocked (const char *s, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fputs_unlocked function is equivalent to the fputs function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: int fputws_unlocked (const wchar_t *ws, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fputws_unlocked function is equivalent to the fputws function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: int puts (const char *s)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The puts function writes the string s to the stream stdout followed by a newline. The terminating null character of the string is not written. (Note that fputs does not write a newline as this function does.)

puts is the most convenient function for printing simple messages. For example:

puts ("This is a message.");
outputs the text ‘This is a message.’ followed by a newline.

Function: int putw (int w, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This function writes the word w (that is, an int) to stream. It is provided for compatibility with SVID, but we recommend you use fwrite instead (see Block Input/Output).

Next: Line-Oriented Input, Previous: Simple Output by Characters or Lines, Up: Input/Output on Streams   [Contents][Index]

12.8 Character Input
This section describes functions for performing character-oriented input. These narrow stream functions are declared in the header file stdio.h and the wide character functions are declared in wchar.h.

These functions return an int or wint_t value (for narrow and wide stream functions respectively) that is either a character of input, or the special value EOF/WEOF (usually -1). For the narrow stream functions it is important to store the result of these functions in a variable of type int instead of char, even when you plan to use it only as a character. Storing EOF in a char variable truncates its value to the size of a character, so that it is no longer distinguishable from the valid character ‘(char) -1’. So always use an int for the result of getc and friends, and check for EOF after the call; once you’ve verified that the result is not EOF, you can be sure that it will fit in a ‘char’ variable without loss of information.

Function: int fgetc (FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This function reads the next character as an unsigned char from the stream stream and returns its value, converted to an int. If an end-of-file condition or read error occurs, EOF is returned instead.

Function: wint_t fgetwc (FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This function reads the next wide character from the stream stream and returns its value. If an end-of-file condition or read error occurs, WEOF is returned instead.

Function: int fgetc_unlocked (FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fgetc_unlocked function is equivalent to the fgetc function except that it does not implicitly lock the stream.

Function: wint_t fgetwc_unlocked (FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fgetwc_unlocked function is equivalent to the fgetwc function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: int getc (FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This is just like fgetc, except that it is permissible (and typical) for it to be implemented as a macro that evaluates the stream argument more than once. getc is often highly optimized, so it is usually the best function to use to read a single character.

Function: wint_t getwc (FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This is just like fgetwc, except that it is permissible for it to be implemented as a macro that evaluates the stream argument more than once. getwc can be highly optimized, so it is usually the best function to use to read a single wide character.

Function: int getc_unlocked (FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The getc_unlocked function is equivalent to the getc function except that it does not implicitly lock the stream.

Function: wint_t getwc_unlocked (FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The getwc_unlocked function is equivalent to the getwc function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: int getchar (void)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The getchar function is equivalent to getc with stdin as the value of the stream argument.

Function: wint_t getwchar (void)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The getwchar function is equivalent to getwc with stdin as the value of the stream argument.

Function: int getchar_unlocked (void)
Preliminary: | MT-Unsafe race:stdin | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The getchar_unlocked function is equivalent to the getchar function except that it does not implicitly lock the stream.

Function: wint_t getwchar_unlocked (void)
Preliminary: | MT-Unsafe race:stdin | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The getwchar_unlocked function is equivalent to the getwchar function except that it does not implicitly lock the stream.

This function is a GNU extension.

Here is an example of a function that does input using fgetc. It would work just as well using getc instead, or using getchar () instead of fgetc (stdin). The code would also work the same for the wide character stream functions.

int
y_or_n_p (const char *question)
{
  fputs (question, stdout);
  while (1)
    {
      int c, answer;
      /* Write a space to separate answer from question. */
      fputc (' ', stdout);
      /* Read the first character of the line.
	 This should be the answer character, but might not be. */
      c = tolower (fgetc (stdin));
      answer = c;
      /* Discard rest of input line. */
      while (c != '\n' && c != EOF)
	c = fgetc (stdin);
      /* Obey the answer if it was valid. */
      if (answer == 'y')
	return 1;
      if (answer == 'n')
	return 0;
      /* Answer was invalid: ask for valid answer. */
      fputs ("Please answer y or n:", stdout);
    }
}
Function: int getw (FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This function reads a word (that is, an int) from stream. It’s provided for compatibility with SVID. We recommend you use fread instead (see Block Input/Output). Unlike getc, any int value could be a valid result. getw returns EOF when it encounters end-of-file or an error, but there is no way to distinguish this from an input word with value -1.

Next: Unreading, Previous: Character Input, Up: Input/Output on Streams   [Contents][Index]

12.9 Line-Oriented Input
Since many programs interpret input on the basis of lines, it is convenient to have functions to read a line of text from a stream.

Standard C has functions to do this, but they aren’t very safe: null characters and even (for gets) long lines can confuse them. So the GNU C Library provides the nonstandard getline function that makes it easy to read lines reliably.

Another GNU extension, getdelim, generalizes getline. It reads a delimited record, defined as everything through the next occurrence of a specified delimiter character.

All these functions are declared in stdio.h.

Function: ssize_t getline (char **lineptr, size_t *n, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt heap | AC-Unsafe lock corrupt mem | See POSIX Safety Concepts.

This function reads an entire line from stream, storing the text (including the newline and a terminating null character) in a buffer and storing the buffer address in *lineptr.

Before calling getline, you should place in *lineptr the address of a buffer *n bytes long, allocated with malloc. If this buffer is long enough to hold the line, getline stores the line in this buffer. Otherwise, getline makes the buffer bigger using realloc, storing the new buffer address back in *lineptr and the increased size back in *n. See Unconstrained Allocation.

If you set *lineptr to a null pointer, and *n to zero, before the call, then getline allocates the initial buffer for you by calling malloc. This buffer remains allocated even if getline encounters errors and is unable to read any bytes.

In either case, when getline returns, *lineptr is a char * which points to the text of the line.

When getline is successful, it returns the number of characters read (including the newline, but not including the terminating null). This value enables you to distinguish null characters that are part of the line from the null character inserted as a terminator.

This function is a GNU extension, but it is the recommended way to read lines from a stream. The alternative standard functions are unreliable.

If an error occurs or end of file is reached without any bytes read, getline returns -1.

Function: ssize_t getdelim (char **lineptr, size_t *n, int delimiter, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt heap | AC-Unsafe lock corrupt mem | See POSIX Safety Concepts.

This function is like getline except that the character which tells it to stop reading is not necessarily newline. The argument delimiter specifies the delimiter character; getdelim keeps reading until it sees that character (or end of file).

The text is stored in lineptr, including the delimiter character and a terminating null. Like getline, getdelim makes lineptr bigger if it isn’t big enough.

getline is in fact implemented in terms of getdelim, just like this:

ssize_t
getline (char **lineptr, size_t *n, FILE *stream)
{
  return getdelim (lineptr, n, '\n', stream);
}
Function: char * fgets (char *s, int count, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The fgets function reads characters from the stream stream up to and including a newline character and stores them in the string s, adding a null character to mark the end of the string. You must supply count characters worth of space in s, but the number of characters read is at most count - 1. The extra character space is used to hold the null character at the end of the string.

If the system is already at end of file when you call fgets, then the contents of the array s are unchanged and a null pointer is returned. A null pointer is also returned if a read error occurs. Otherwise, the return value is the pointer s.

Warning: If the input data has a null character, you can’t tell. So don’t use fgets unless you know the data cannot contain a null. Don’t use it to read files edited by the user because, if the user inserts a null character, you should either handle it properly or print a clear error message. We recommend using getline instead of fgets.

Function: wchar_t * fgetws (wchar_t *ws, int count, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The fgetws function reads wide characters from the stream stream up to and including a newline character and stores them in the string ws, adding a null wide character to mark the end of the string. You must supply count wide characters worth of space in ws, but the number of characters read is at most count - 1. The extra character space is used to hold the null wide character at the end of the string.

If the system is already at end of file when you call fgetws, then the contents of the array ws are unchanged and a null pointer is returned. A null pointer is also returned if a read error occurs. Otherwise, the return value is the pointer ws.

Warning: If the input data has a null wide character (which are null bytes in the input stream), you can’t tell. So don’t use fgetws unless you know the data cannot contain a null. Don’t use it to read files edited by the user because, if the user inserts a null character, you should either handle it properly or print a clear error message.

Function: char * fgets_unlocked (char *s, int count, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fgets_unlocked function is equivalent to the fgets function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: wchar_t * fgetws_unlocked (wchar_t *ws, int count, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fgetws_unlocked function is equivalent to the fgetws function except that it does not implicitly lock the stream.

This function is a GNU extension.

Deprecated function: char * gets (char *s)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The function gets reads characters from the stream stdin up to the next newline character, and stores them in the string s. The newline character is discarded (note that this differs from the behavior of fgets, which copies the newline character into the string). If gets encounters a read error or end-of-file, it returns a null pointer; otherwise it returns s.

Warning: The gets function is very dangerous because it provides no protection against overflowing the string s. The GNU C Library includes it for compatibility only. You should always use fgets or getline instead. To remind you of this, the linker (if using GNU ld) will issue a warning whenever you use gets.

Next: Block Input/Output, Previous: Line-Oriented Input, Up: Input/Output on Streams   [Contents][Index]

12.10 Unreading
In parser programs it is often useful to examine the next character in the input stream without removing it from the stream. This is called “peeking ahead” at the input because your program gets a glimpse of the input it will read next.

Using stream I/O, you can peek ahead at input by first reading it and then unreading it (also called pushing it back on the stream). Unreading a character makes it available to be input again from the stream, by the next call to fgetc or other input function on that stream.

What Unreading Means
Using ungetc To Do Unreading
Next: Using ungetc To Do Unreading, Up: Unreading   [Contents][Index]

12.10.1 What Unreading Means
Here is a pictorial explanation of unreading. Suppose you have a stream reading a file that contains just six characters, the letters ‘foobar’. Suppose you have read three characters so far. The situation looks like this:

f  o  o  b  a  r
	 ^
so the next input character will be ‘b’.

If instead of reading ‘b’ you unread the letter ‘o’, you get a situation like this:

f  o  o  b  a  r
	 |
      o--
      ^
so that the next input characters will be ‘o’ and ‘b’.

If you unread ‘9’ instead of ‘o’, you get this situation:

f  o  o  b  a  r
	 |
      9--
      ^
so that the next input characters will be ‘9’ and ‘b’.

Previous: What Unreading Means, Up: Unreading   [Contents][Index]

12.10.2 Using ungetc To Do Unreading
The function to unread a character is called ungetc, because it reverses the action of getc.

Function: int ungetc (int c, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The ungetc function pushes back the character c onto the input stream stream. So the next input from stream will read c before anything else.

If c is EOF, ungetc does nothing and just returns EOF. This lets you call ungetc with the return value of getc without needing to check for an error from getc.

The character that you push back doesn’t have to be the same as the last character that was actually read from the stream. In fact, it isn’t necessary to actually read any characters from the stream before unreading them with ungetc! But that is a strange way to write a program; usually ungetc is used only to unread a character that was just read from the same stream. The GNU C Library supports this even on files opened in binary mode, but other systems might not.

The GNU C Library only supports one character of pushback—in other words, it does not work to call ungetc twice without doing input in between. Other systems might let you push back multiple characters; then reading from the stream retrieves the characters in the reverse order that they were pushed.

Pushing back characters doesn’t alter the file; only the internal buffering for the stream is affected. If a file positioning function (such as fseek, fseeko or rewind; see File Positioning) is called, any pending pushed-back characters are discarded.

Unreading a character on a stream that is at end of file clears the end-of-file indicator for the stream, because it makes the character of input available. After you read that character, trying to read again will encounter end of file.

Function: wint_t ungetwc (wint_t wc, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

The ungetwc function behaves just like ungetc just that it pushes back a wide character.

Here is an example showing the use of getc and ungetc to skip over whitespace characters. When this function reaches a non-whitespace character, it unreads that character to be seen again on the next read operation on the stream.

#include <stdio.h>
#include <ctype.h>

void
skip_whitespace (FILE *stream)
{
  int c;
  do
    /* No need to check for EOF because it is not
       isspace, and ungetc ignores EOF.  */
    c = getc (stream);
  while (isspace (c));
  ungetc (c, stream);
}
Next: Formatted Output, Previous: Unreading, Up: Input/Output on Streams   [Contents][Index]

12.11 Block Input/Output
This section describes how to do input and output operations on blocks of data. You can use these functions to read and write binary data, as well as to read and write text in fixed-size blocks instead of by characters or lines.

Binary files are typically used to read and write blocks of data in the same format as is used to represent the data in a running program. In other words, arbitrary blocks of memory—not just character or string objects—can be written to a binary file, and meaningfully read in again by the same program.

Storing data in binary form is often considerably more efficient than using the formatted I/O functions. Also, for floating-point numbers, the binary form avoids possible loss of precision in the conversion process. On the other hand, binary files can’t be examined or modified easily using many standard file utilities (such as text editors), and are not portable between different implementations of the language, or different kinds of computers.

These functions are declared in stdio.h.

Function: size_t fread (void *data, size_t size, size_t count, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This function reads up to count objects of size size into the array data, from the stream stream. It returns the number of objects actually read, which might be less than count if a read error occurs or the end of the file is reached. This function returns a value of zero (and doesn’t read anything) if either size or count is zero.

If fread encounters end of file in the middle of an object, it returns the number of complete objects read, and discards the partial object. Therefore, the stream remains at the actual end of the file.

Function: size_t fread_unlocked (void *data, size_t size, size_t count, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fread_unlocked function is equivalent to the fread function except that it does not implicitly lock the stream.

This function is a GNU extension.

Function: size_t fwrite (const void *data, size_t size, size_t count, FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe lock corrupt | See POSIX Safety Concepts.

This function writes up to count objects of size size from the array data, to the stream stream. The return value is normally count, if the call succeeds. Any other value indicates some sort of error, such as running out of space.

Function: size_t fwrite_unlocked (const void *data, size_t size, size_t count, FILE *stream)
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Unsafe corrupt | See POSIX Safety Concepts.

The fwrite_unlocked function is equivalent to the fwrite function except that it does not implicitly lock the stream.

This function is a GNU extension.

Next: Customizing printf, Previous: Block Input/Output, Up: Input/Output on Streams   [Contents][Index]

12.12 Formatted Output
The functions described in this section (printf and related functions) provide a convenient way to perform formatted output. You call printf with a format string or template string that specifies how to format the values of the remaining arguments.

Unless your program is a filter that specifically performs line- or character-oriented processing, using printf or one of the other related functions described in this section is usually the easiest and most concise way to perform output. These functions are especially useful for printing error messages, tables of data, and the like.

Formatted Output Basics
Output Conversion Syntax
Table of Output Conversions
Integer Conversions
Floating-Point Conversions
Other Output Conversions
Formatted Output Functions
Dynamically Allocating Formatted Output
Variable Arguments Output Functions
Parsing a Template String
Example of Parsing a Template String
Next: Output Conversion Syntax, Up: Formatted Output   [Contents][Index]

12.12.1 Formatted Output Basics
The printf function can be used to print any number of arguments. The template string argument you supply in a call provides information not only about the number of additional arguments, but also about their types and what style should be used for printing them.

Ordinary characters in the template string are simply written to the output stream as-is, while conversion specifications introduced by a ‘%’ character in the template cause subsequent arguments to be formatted and written to the output stream. For example,

int pct = 37;
char filename[] = "foo.txt";
printf ("Processing of `%s' is %d%% finished.\nPlease be patient.\n",
	filename, pct);
produces output like

Processing of `foo.txt' is 37% finished.
Please be patient.
This example shows the use of the ‘%d’ conversion to specify that an int argument should be printed in decimal notation, the ‘%s’ conversion to specify printing of a string argument, and the ‘%%’ conversion to print a literal ‘%’ character.

There are also conversions for printing an integer argument as an unsigned value in binary, octal, decimal, or hexadecimal radix (‘%b’, ‘%o’, ‘%u’, or ‘%x’, respectively); or as a character value (‘%c’).

Floating-point numbers can be printed in normal, fixed-point notation using the ‘%f’ conversion or in exponential notation using the ‘%e’ conversion. The ‘%g’ conversion uses either ‘%e’ or ‘%f’ format, depending on what is more appropriate for the magnitude of the particular number.

You can control formatting more precisely by writing modifiers between the ‘%’ and the character that indicates which conversion to apply. These slightly alter the ordinary behavior of the conversion. For example, most conversion specifications permit you to specify a minimum field width and a flag indicating whether you want the result left- or right-justified within the field.

The specific flags and modifiers that are permitted and their interpretation vary depending on the particular conversion. They’re all described in more detail in the following sections. Don’t worry if this all seems excessively complicated at first; you can almost always get reasonable free-format output without using any of the modifiers at all. The modifiers are mostly used to make the output look “prettier” in tables.

Next: Table of Output Conversions, Previous: Formatted Output Basics, Up: Formatted Output   [Contents][Index]

12.12.2 Output Conversion Syntax
This section provides details about the precise syntax of conversion specifications that can appear in a printf template string.

Characters in the template string that are not part of a conversion specification are printed as-is to the output stream. Multibyte character sequences (see Character Set Handling) are permitted in a template string.

The conversion specifications in a printf template string have the general form:

% [ param-no $] flags width [ . precision ] type conversion
or

% [ param-no $] flags width . * [ param-no $] type conversion
For example, in the conversion specifier ‘%-10.8ld’, the ‘-’ is a flag, ‘10’ specifies the field width, the precision is ‘8’, the letter ‘l’ is a type modifier, and ‘d’ specifies the conversion style. (This particular type specifier says to print a long int argument in decimal notation, with a minimum of 8 digits left-justified in a field at least 10 characters wide.)

In more detail, output conversion specifications consist of an initial ‘%’ character followed in sequence by:

An optional specification of the parameter used for this format. Normally the parameters to the printf function are assigned to the formats in the order of appearance in the format string. But in some situations (such as message translation) this is not desirable and this extension allows an explicit parameter to be specified.
The param-no parts of the format must be integers in the range of 1 to the maximum number of arguments present to the function call. Some implementations limit this number to a certain upper bound. The exact limit can be retrieved by the following constant.

Macro: NL_ARGMAX
The value of NL_ARGMAX is the maximum value allowed for the specification of a positional parameter in a printf call. The actual value in effect at runtime can be retrieved by using sysconf using the _SC_NL_ARGMAX parameter see Definition of sysconf.

Some systems have a quite low limit such as 9 for System V systems. The GNU C Library has no real limit.

If any of the formats has a specification for the parameter position all of them in the format string shall have one. Otherwise the behavior is undefined.

Zero or more flag characters that modify the normal behavior of the conversion specification.
An optional decimal integer specifying the minimum field width. If the normal conversion produces fewer characters than this, the field is padded with spaces to the specified width. This is a minimum value; if the normal conversion produces more characters than this, the field is not truncated. Normally, the output is right-justified within the field.
You can also specify a field width of ‘*’. This means that the next argument in the argument list (before the actual value to be printed) is used as the field width. The value must be an int. If the value is negative, this means to set the ‘-’ flag (see below) and to use the absolute value as the field width.

An optional precision to specify the number of digits to be written for the numeric conversions. If the precision is specified, it consists of a period (‘.’) followed optionally by a decimal integer (which defaults to zero if omitted).
You can also specify a precision of ‘*’. This means that the next argument in the argument list (before the actual value to be printed) is used as the precision. The value must be an int, and is ignored if it is negative. If you specify ‘*’ for both the field width and precision, the field width argument precedes the precision argument. Other C library versions may not recognize this syntax.

An optional type modifier character, which is used to specify the data type of the corresponding argument if it differs from the default type. (For example, the integer conversions assume a type of int, but you can specify ‘h’, ‘l’, or ‘L’ for other integer types.)
A character that specifies the conversion to be applied.
The exact options that are permitted and how they are interpreted vary between the different conversion specifiers. See the descriptions of the individual conversions for information about the particular options that they use.

With the ‘-Wformat’ option, the GNU C compiler checks calls to printf and related functions. It examines the format string and verifies that the correct number and types of arguments are supplied. There is also a GNU C syntax to tell the compiler that a function you write uses a printf-style format string. See Declaring Attributes of Functions in Using GNU CC, for more information.

Next: Integer Conversions, Previous: Output Conversion Syntax, Up: Formatted Output   [Contents][Index]

12.12.3 Table of Output Conversions
Here is a table summarizing what all the different conversions do:

‘%d’, ‘%i’
Print an integer as a signed decimal number. See Integer Conversions, for details. ‘%d’ and ‘%i’ are synonymous for output, but are different when used with scanf for input (see Table of Input Conversions).
